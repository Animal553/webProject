## 一、微服务网关

### 前言

​        随着微服务的兴起，基于其业务耦合性低、负载能力强、服务边界清晰等优点，大家纷纷使用微服务架构来实现新系统或进行老系统的改造。微服务在带来诸多好处的同时，也有一些问题需要解决，比如：如何做到有效拆分、减少服务间调用，**如何统一管理所有服务的接口**，如何进行自动化部署等。本节阐述微服务的API网关的一些主要功能，并例举了几种常用的网关，最后结合spring cloud微服务框架对网关做一些简要的论述。

### 问题

不同的微服务一般都会有不同的网络地址，而外部客户端在该问一个主页面时，数据可能需要调用多个服务的接口才能完成一个业务需求。

![](images-zuul\2.png)

### 网关简介

​        API网关，顾名思义，是统一管理API的一个网络关口、通道，是整个微服务平台所有请求的唯一入口，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。下图为微服务架构的简单示意图，网关起到的作用一目了然。



![](images-zuul\3.png)





![](images-zuul\1.png)



### 微服务网关作用

 为微服务云平台提供统一的入口是API网关最主要的用途，除此之外，网关还可承担**认证授权、访问控制、路由、负载均衡、缓存、日志、限流限额、转换、映射、过滤、熔断、注册、服务编排、API管理、监控、统计分析**等等非业务性的功能。



### 主流网关产品

 目前比较常见的几种开源的API网关有以下几种：**Zuul 、SpringCloud Getway**、Kong、Treafik、Ambassador、Tyk。

**目前能和spring cloud体系紧密集成的有两种API网关：zuul（zuul1）和spring cloud gateway。**

#### zuul

|          | zuul1                                               | zuul2                                                        |
| -------- | --------------------------------------------------- | ------------------------------------------------------------ |
| 优势     | 模型简单，跟踪调试方便。                            | 线程相对较少，对cpu、内存的开销少。                            可以接受相对较大的连接数。 |
| 劣势     | cpu、内存消耗相对较大。IO阻塞容器导致线程池被耗尽。 | 由于是通过事件环线程监听的异步处理方式，没有明确的请求链路   |
| 性能     | 950.57 次 /s（单核）                                | 大致比zuul1好20%左右                                         |
| 使用场景 | 适用于计算密集型 (CPU bound) 应用场景               | 适用于 IO 密集型 (IO bound) 场景                             |
|          |                                                     |                                                              |

总结：建议是在生产环境中使用 zuul



#### SpringCloud Gaetway

  Spring Cloud Gateway构建于 Spring 5+，基于 Spring Boot 2.x 响应式的、非阻塞式的 API。同时，它支持 websockets，和 Spring 框架紧密集成，开发体验相对来说十分不错。

zuul1与spring cloud gateway做一些简单的比较。

```bat
Gateway介绍：
	Spring Cloud Gateway是Spring官方基于Spring 5.0，Spring Boot 2.0和Project Reactor等技术开发的网关，旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring 用其替代Netflix ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。

性能：
WebFlux 模块的名称是 spring-webflux，名称中的 Flux 来源于 Reactor 中的类 Flux。Spring webflux 有一个全新的非堵塞的函数式 Reactive Web 框架，可以用来构建异步的、非堵塞的、事件驱动的服务，在伸缩性方面表现非常好。使用非阻塞API。 Websockets得到支持，并且由于它与Spring紧密集成。 

源码维护组织：
 spring-cloud-Gateway是spring旗下spring-cloud的一个子项目。还有一种说法是因为zuul2连续跳票和zuul1的性能表现不是很理想，所以催生了spring孵化Gateway项目。

版本：
基于springboot2.0
```



```bat
Zuul1介绍：
	Zuul1 是基于 Servlet 框架构建，采用的是阻塞和多线程方式，即一个线程处理一次连接请求，这种方式在内部延迟严重、设备故障较多情况下会引起存活的连接增多和线程增加的情况发生。

性能:
	Zuul 1.x，是一个基于阻塞io的API Gateway。Zuul已经发布了Zuul 2.x，基于Netty，也是非阻塞的，支持长连接，但Spring Cloud暂时还没有整合计划。

源码维护组织:
	zuul则是netflix公司的项目，只是spring将zuul集成在spring-cloud中使用而已。关键目前spring不打算集成zuul2.x。
	
版本:
	springboot1.x
```

**spring官方给出的性能测试数据：**

| 组件                 | RPS(request per second) |
| -------------------- | ----------------------- |
| Spring Cloud Gateway | Requests/sec: 32213.38  |
| Zuul1.x              | Requests/sec: 20800.13  |

从表中可以看出，spring cloud gateway在性能上还是胜zuul一筹的，而且上手也简单。

        一些API网关（Zuul1）是阻塞的，另外一些（Zuul2、Linkerd、Envoy）是非阻塞的。阻塞架构对开发和跟踪请求友好，但是阻塞可能产生扩展性问题。非阻塞架构对于团队开发和跟踪更复杂，但是有更好的可扩展和弹性。如何选择还是需要根据实际情况再做抉择。


##  二、微服务网关Zuul

　　**Zuul是Netflix开源的微服务网关，它可以和Eureka、Ribbon、Hystrix等组件配合使用，它主要用作反向代理、Filter扩展、动态加载、动态路由、压力测试、弹性扩展、审查监控、安全检查等。**



**动态路由：**动态将请求路由到不同后端集群
**压力测试：**逐渐增加指向集群的流量，以了解性能
**负载分配：**为每一种负载类型分配对应容量，并弃用超出限定值的请求
**静态响应处理：**边缘位置进行响应，避免转发到内部集群
**身份认证和安全:** 识别每一个资源的验证要求，并拒绝那些不符的请求。

Spring Cloud对Zuul进行了整合和增强



### 创建dudu-zuul微服务

![](images-zuul\4.png)

#### pom

```bat
<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!-- Eureka Client 客户端start -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <!-- Eureka Client 客户端end -->
        <!-- NetFlix zuul  客户端start-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
        </dependency>
        <!-- NetFlix zuul  客户端end-->
```





#### 启动类

在启动类上添加注解@EnableZuulProxy，声明ZUUL代理，通过观察Zuul的类库发现，zuul的依赖库中除了有它本身的核心包外还有**actuator、hystrix**的整合包，默认实现了监控和熔断机制，所有经过zuul的请求都会在hystrix命令中执行：

```java
@SpringBootApplication
@EnableZuulProxy  //声明ZUUL代理
@EnableDiscoveryClient //Eureka配置
public class DuduZuulApplication {
    public static void main(String[] args) {
        SpringApplication.run(DuduZuulApplication.class, args);
    }
}
```

#### 编写配置文件application.yml

```yml
# eureka
eureka:
  client:
    service-url:
      defaultZone: http://localhost:9001/eureka/
  instance:
    prefer-ip-address: true      
server:
  port: 8000  # zuul服务器地址
spring:
  application:
    name: dudu-zuul #服务名称
```



#### 基础路由配置：

**“路由”是指根据请求URL，将请求分配到对应的处理程序。在微服务体系中，Zuul负责 接收所有的请求。根据不同的URL匹配规则，将不同的请求转发到不同的微服务处理。**

```yml
zuul:
  routes:
    baidu:
      path: /jd    #映射请求 localhost:8000/jd   即到映射的地址
      url: https://www.jd.com/
```

```yml
zuul:
  routes:
    dudu-user: #用户微服务(路由)id 随便编写
      path: /dudu-user/** #映射路径 http://localhost:8081/dudu-user/**
      url: http://localhost:8081/dudu-user #映射路径对应的实际请求地址
```

**解读如上配置：**

只需要在application.yml文件中配置路由规则即可：
**dudu-user：**配置路由id，可以随意取名 

**url：**映射路径对应的实际请求地址

**path：**配置映射路径，这里将所有请求前缀为/dudu-user/的请求，转发到http://127.0.0.1: 8081处理 

配置好Zuul路由之后启动服务，在浏览器中输入 http://localhost:8000/dudu-user/user/1 ，即可访问到订单微服务。

**此刻，我们发现对外入口的统一处就变成了8000了。**



### 面向服务路由配置

#### 问题：

微服务一般是由几十、上百个服务组成，对于一个URL请求，终会确认一个服务实例进行处理。如果 对每个服务实例手动指定一个唯一访问地址，然后根据URL去手动实现请求匹配，这样做显然就不合 理。

```yml
zuul:
  routes:
    dudu-user:  #用户微服务
      path: /dudu-user/**
      url: http://localhost:8081/dudu-user/
    dudu-meeting-feign:   #会议微服务
      path: /dudu-meeting-feign/**
      url: http://localhost:8080/dudu-meeting-feign/
```



#### 使用Eureka配置：

导主Eureka依赖

```xml
 <!--1、 Eureka Client 客户端start -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <!-- Eureka Client 客户端end -->
```

```yml
# 2、 application.yml配置 eureka
eureka:
  client:
    service-url:
      defaultZone: http://localhost:9001/eureka/
  instance:
    prefer-ip-address: true    
    
# 3、启动类上方加入@EnableEureka    
```

  **serviceId: dudu-user #在Eureka中通过微服务的服务名称得到IP和地址**

因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而 是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。

```yml
zuul:
  routes:
    dudu-user: #用户微服务id 随便编写
      path: /dudu-user/** # http://localhost:8081/dudu-user/**
      #url: http://localhost:8081/dudu-user/ #映射路径对应的地址
      serviceId: dudu-user #在Eureka中通过微服务的服务名称得到IP和地址
    dudu-meeting-feign:
      path: /dudu-meeting-feign/**
      #url: http://localhost:8080/dudu-meeting-feign/
      serviceId: dudu-meeting-feign  
```

serviceId: 指定需要转发的微服务实例名

浏览器访问地址：

 <http://localhost:8000/dudu-user/dudu-user/user/1>



**报错备注：**

com.netflix.zuul.exception.ZuulException: Forwarding error

原因是zuul部署上物理机后的请求超时，导致出现了500错误。

```yml
ribbon:  
  ReadTimeout: 3000
  ConnectTimeout: 3000
zuul:
    host:
        connect-timeout-millis: 3000
        socket-timeout-millis: 3000
hystrix:
    command:
        default:
            execution:
                isolation:
                    thread:
                        timeout-in-milliseconds: 3000
```



#### 简化配置

如果**路由id**和对应的**微服务 名称**一致的话

可简化：

```
zuul:
  routes:
    dudu-user: /dudu-user/**
```

**最终简化：**

**zuul中的默认则不需要配置**

```

```



**最终完整applicatation.yml**

```yml
server:
  port: 8000
spring:
  application:
    name: dudu-zuul

eureka:
  client:
    service-url:
      defaultZone: http://Wilson:123456@localhost:9001/eureka/
  instance:
    prefer-ip-address: true
```



### Zuul监控界面

`在实际开发中，当默认简化Zuul配置后，有时想看一下Zuul相关路由信息。`

> 1、导入actuator依赖
>
> ```xml
> <!-- actuator依赖 -->
> <dependency>
>     <groupId>org.springframework.boot</groupId>
>     <artifactId>spring-boot-starter-actuator</artifactId>
> </dependency>
> ```

> 2、application.yml 开放端点
>
> ```yml
> management:
>   endpoints:
>     web:
>       exposure:
>         include: "*"
> ```

> 3、直接访问即可看到所有路由信息 
>
> <http://localhost:8000/actuator/routes>

### Zuul忽略配置

dudu-zuul.application.yml

> ```yml
> zuul:
>   #要忽略的服务（Eureka中微服务）  ignored-services: "*"  忽略全部服务
>   ignored-services: dudu-video
>   #要忽略的路径请求 （actuator可查看，但请求已被忽略)
>   ignored-patterns: /**/dudu-meeting/**
> ```

### 过滤器

#### 简介

**zuul加入后的当前架构**

<https://www.processon.com/diagraming/5e2fc771e4b049828098941d>



**Spring Cloud Zuul包含了对请求的路由和过滤2个功能**

> 路由功能负责将请求转发到具体的微服务上，
>
> 而过滤器负责对请求的处理过程进行干预，是实现权限校验、服务聚合等功能的基础。

在实际运行时，路由映射和请求转发是由几个不同的过滤器完成的。每一个进入zuul的http请求都会经过一系列的过滤器处理链得到请求响应并返回给客户端。

**Spring Cloud Zuul包含4种类型的过滤器**

- **pre过滤器**。在请求被路由之前调用。Zuul请求微服务之前。比如请求身份验证，选择微服务实例，记录调试信息等。
- **route过滤器**。负责转发请求到微服务。原始请求在此构建，并使用Apache HttpClient或Netflix Ribbon发送原始请求。
- **post过滤器**。在route和error过滤器之后被调用。可以在响应添加标准HTTP Header、收集统计信息和指标，以及将响应发送给客户端等。
- **error过滤器**。在处理请求发生错误时被调用。


![](images-zuul\5.png)

#### 示例代码实现

**要想实现Filter，通过继承ZuulFilter然后重写上面的4个方法，就可以实现一个简单的过滤器**，

![](images-zuul\6.png)

```java
package com.qfjy.dudu.filter;

import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.exception.ZuulException;
import org.springframework.stereotype.Component;

/**
 * @ClassName AuthFilter
 * @Description TODO
 * @Author guoweixin
 * @Version 1.0
 */
@Component
public class AuthFilter extends ZuulFilter {
    /*
   - pre过滤器。在请求被路由之前调用。Zuul请求微服务之前。比如请求身份验证，选择微服务实例，记录调试信息等。
   - route过滤器。负责转发请求到微服务。原始请求在此构建，并使用Apache HttpClient或Netflix Ribbon发送原始请求。
   -post过滤器。在route和error过滤器之后被调用。可以在响应添加标准HTTP Header、收集统计信息和指标，以及将响应发送给客户端等。
   -error过滤器。在处理请求发生错误时被调用。
    */
    //指定过滤器类型
    @Override
    public String filterType() {
        //"pre"
        return FilterConstants.PRE_TYPE; 
    }

    //指定过滤器优先级 过滤器顺序，数字越小越先执行
    @Override
    public int filterOrder() {
        return 0;
    }
    //是否使用该过滤器。
    @Override
    public boolean shouldFilter() {

        return true;
    }

    //过滤器具体执行的操作
    @Override
    public Object run() throws ZuulException {
        System.out.println("-------AuthFilter执行过滤器的业务具体逻辑-------");
        return null;
    }
}
```



启动运行URL，访问，即可看到打印的 内容。

```
http://localhost:8000/dudu-user/dudu-user/user/1

http://localhost:8000/dudu-meeting-feign/dudu-meeting-feign/meetingpub/02372a1b-5aa7-4333-abe0-55899b5c74b7
```



## 三、Zuul整合JWT实战

**模拟登录（JWT方式）**

定义了一个Zuul过滤器，实现了在请求被路由之前检查请求中是否有`accessToken`参数，若有就进行路由，若没有就拒绝访问，返回`JSON提示{4000,"用户未登录或token过期"}`错误



```java
  /**
         过滤器具体执行的操作
        需求：用户请求中是否传递accessToken，如果存在，则访问资源，如果不存在，则返回失败参数。
        1、得到request对象   Zuul提供了RequestContext
        2、在request中获得请求的acessToken值
        3、判断accessToken是否为空
     */
    @Override
    public Object run() throws ZuulException {
        System.out.println("-------AuthFilter执行过滤器的业务具体逻辑-------");

         RequestContext ctx=RequestContext.getCurrentContext();
        HttpServletRequest request=ctx.getRequest();

        log.info(String.format("%s  请求的地址是：  %s",request.getMethod(),request.getRequestURL()));

        Object  accessToken=request.getParameter("accessToken");
        if(accessToken==null){
            log.warn(" accessToken is empyt 用户没有认证信息。登录失败");

            //   ctx.setSendZuulResponse(false);//响应失败
            ctx.getResponse().setCharacterEncoding("GBK");

            //设定响应体代码给前端
            Object obj= new ResultJson(null,ResultCode.NOT_LOGIN);
            ObjectMapper objectMapper=new ObjectMapper();
            try {
                String responseBodyStr= objectMapper.writeValueAsString(obj);
                ctx.setResponseBody(responseBodyStr);
            } catch (JsonProcessingException e) {
                e.printStackTrace();
            }
            return null;
        }
        log.info("token  success---");
        return null;
        
    }
```



## 四、微服务Zull降级

`在微服务里有Hystrix的Fallback机制，当微服务应用本身发生问题后，微服务会进行服务降级。`

`当然客户端通过网关调用消费者无法调用时，zuul也具有服务降级功能。`

**Zuul会处理所有服务统一入口内，没有进行降级的方法**

**1、Hystrix依赖包（默认不需要导入。Zuul已默认依赖**

**2、创建降级类**

> ```bat
> com.qfjy.fallback.Zuulfallback  并实现  FallbackProvider接口
> ```

> ```java
> **
>  * @ClassName ZuulFallback
>  * @Description TODO
>  * @Author guoweixin
>  * @Date 2020/2/15
>  * @Version 1.0
>  */
> @Component
> public class ZuulFallback implements FallbackProvider {
>     @Override
>     public String getRoute() {
>         //可以配置指定的路由，值为serviceId  如 dudu-video
>         //  *代表全部出现问题的服务，都走Zull降级方法
>         return "*";
>     }
> 
>     /**
>      * @param route  路由服务的 名称
>      * @param cause  异常的信息（常用于日志记录）
>      * @return
>      */
>     @Override
>     public ClientHttpResponse fallbackResponse(String route, Throwable cause) {
>         System.out.println("记录日志：路由的服务是："+route+"\t"+cause.getMessage());
>         return new ClientHttpResponse() {
>             @Override
>             public HttpStatus getStatusCode() throws IOException {
>                 //具体的状态码 500
>                 return HttpStatus.INTERNAL_SERVER_ERROR;
>             }
> 
>             @Override
>             public int getRawStatusCode() throws IOException {
>                 //返回原始状态码
>                 return HttpStatus.INTERNAL_SERVER_ERROR.value();
>             }
> 
>             @Override
>             public String getStatusText() throws IOException {
>                 //指定错误状态文本信息
>                 return HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase();
>             }
> 
>             @Override
>             public void close() {
>             }
> 
>             @Override
>             public InputStream getBody() throws IOException {
>                String msg=route+"服务器开小差了..";
>                 return new ByteArrayInputStream(msg.getBytes());
>             }
>             @Override
>             public HttpHeaders getHeaders() {
>                 //响应头信息 JSON格式
>                 HttpHeaders httpHeaders=new HttpHeaders();
>                 httpHeaders.setContentType(MediaType.APPLICATION_JSON);
>                 return httpHeaders;
>             }
>         };
>     }
> }
> ```

## 五、SpringCloud Geatway

### 简介

  Spring Cloud Gateway构建于 Spring 5+，基于 Spring Boot 2.x 响应式的、非阻塞式的 API。同时，它支持 websockets，和 Spring 框架紧密集成。



### 核心概念

根据如图，查看Spring Cloud Gateway重要的概念：

![](images-zuul\6-gateway.jpg)



```bat
路由(route)。路由是网关最基础的部分,路由信息由一个 ID、一个目的 url、一组断言工厂和一组Filter组成。如果路由断言为真,则说明请求的url和配置的路由匹配

断言( Predicate)Java8中的断言函数, Spring Cloud Gateway中的断言函数输人类型是 Spring5.0框架中的 Server Web Exchange. Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自于 Http Request中的任何信息,比如请求头和参数等。

过滤器(filter)。一个标准的 Spring webFilter. Spring Cloud Gateway中的Fler分为
两种类型的 Filter,分别是 Gateway Filter和 Global Filter过滤器 Filter将会对请求和响应进行修改处理。
```

### 工作原理

![](images-zuul\7-gateway.jpg)



网关最重要的功能就是协议适配和协议转发，协议转发也就是基本的路由信息转发。入门案例将演示Spring Cloud Gateway的基本路由转发功能，通过Gateway的Path路由断言工厂实现URL直接转发。

### 入门案例Getway

#### dudu-getway

![](images-zuul\4.jpg)





#### pom

```xml
<!--Spring Cloud gateway Start -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
<!--Spring Cloud gateway End -->
```

#### 路由配置：

 浏览器访问 localhost:8000/java  跳转到 第三方网站

```yml
server:
  port: 8000 #服务器端口号
spring:
  application:
    name: dudu-gateway #应用程序的名字
  cloud:
    gateway:
      routes:  #当访问8000时，直接跳转到第三方网站
        - id: weixin_route #
          uri: https://www.javaqf.com/
          predicates:
           - Path=/java/**
```

在上面的配置中，配置了一个Path 的predict,将以 /java/** 开头的请求都会转发到uri地址上



```bat
路由(route)。路由是网关最基础的部分,路由信息由一个 ID、一个目的 url、一组断言工厂和一组Filter组成。如果路由断言为真,则说明请求的url和配置的路由匹配

断言( Predicate)Java8中的断言函数, Spring Cloud Gateway中的断言函数输人类型是 Spring5.0框架中的 Server Web Exchange. Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自于 Http Request中的任何信息,比如请求头和参数等。

过滤器(filter)。一个标准的 Spring webFilter. Spring Cloud Gateway中的Fler分为
两种类型的 Filter,分别是 Gateway Filter和 Global Filter过滤器 Filter将会对请求和响应进行修改处理。
```

```
访问url: http://localhost:8000/java/..
```



#### 路由断言

​           SpringCloud Gateway的路由匹配的功能是以 Spring WebFlux中的 Handler Mapping为基础实现的 Spring Cloud Gateway也是由许多的路由断言工厂组成的。

​           当 Http Request请求进人 SpringCloud Gateway的时候,网关中的路由断言工厂会根据配置的路由规则,对 Http Request请求进行断言匹配。匹配成功则进行下一步处理,否则断言失败直接返回错误信息。

下面我们介绍下 Spring Cloud Gateway中经常使用的路由断言工厂 。



#####  After路由断言工厂 

After Route Predicate Factory中会取一个 UTC时间格式的时间参数，

**当请求进来的当前时间在配置的UTC时间之后**，则会成功匹配，否则不能成功匹配。

```yml
server:
  port: 8000
spring:
  application:
    name: dudu-gateway
  cloud:
    gateway:
      routes:
        - id: weixin_route #
          uri: https://www.baidu.com/
          predicates:
           - After=2019-6-11T14:06:39.289+08:00[Asia/Shanghai]
```

其中-After UTFC时间 代码生成：

```java
//获取当前时间的前一个小时
String minTime=ZonedDateTime.now().minusHours(1).
    format(DateTimeFormatter.ISO_DATE_TIME);
System.out.println(minTime);	
```



此时再访问：则请求失败

```java
//获取当前时间的后一个小时
String minTime=ZonedDateTime.now().plusHours(1).
    format(DateTimeFormatter.ISO_DATE_TIME);
System.out.println(minTime);
```

##### Before路由断言工厂

Before路由断言工厂会取一个 UTC时间格式的时间参数 ,当请求进来的当前时间在路由断言工厂之前会成功匹配 ,否则不能成功匹配。



##### Between路由断言工厂

Between路由断言工厂会取一个 UTC时间格式的时间参数 ,当请求进来的当前时间在配置的UTC时间工厂之间会成功匹配，否则不能成功匹配。

**application.yml:**

```yml
spring:
  application:
    name: dudu-gateway
  cloud:
    gateway:
      routes:
        - id: weixin_route #
          uri: http://www.javaqf.com/
          predicates:
          - name: Between
            args:
              datetime1: 2019-6-11T14:06:39.289+08:00[Asia/Shanghai]
              datetime2: 2019-6-11T16:06:39.289+08:00[Asia/Shanghai]
```

##### Cookie路由断言工厂

路由断言工厂会取两个参数一cookie名称对应的 key和 value。当请求中携带的cookie和 Cookied断言工厂中配置的 cookie一致 ,则路由匹配成功 ,否则匹配不成功。

##### Header路由断言工厂

Header路由断言工厂用于根据配置的路由 header信息进行断言匹配路由 ,匹配成功进行转发 ,否则不进行转发。

##### Host路由断言工厂

Host路由断言工厂根据配置的 Host,对请求中的 Host进行断言处理 ,断言成功则进行路由转发 ,否则不转发。

##### Method路由断言工厂

Method路由断言工厂会根据路由信息配置的 method对请求方法是Get或者Post等进行断言匹配,匹配成功则进行转发,否则处理失败。

```yml
spring:
  application:
    name: dudu-gateway
  cloud:
    gateway:
      routes:
        - id: weixin_route #
          uri: http://www.javaqf.com/
          predicates:
          - Method=GET
```



##### Query路由断言工厂

Query路由断言工厂会从请求中获取两个参数,将请求中参数和Query断言路由中的配置进行匹配,
例如：http://localhost:8000?name=123中的 name=123和路由配置一致则请求成功。否则转发失败。

```yml
spring:
  application:
    name: dudu-gateway
  cloud:
    gateway:
      routes:
        - id: weixin_route #
          uri: http://www.javaqf.com/
          predicates:
          - Query=name, 123
```

<http://127.0.0.1:8000/?name=123>

##### RemoteAddr路由断言工厂

Remoted路由断言工厂配置一个 IPv4或 IPv6网段的字符串或者IP。当请求IP地址在 网段之内或者和配置的IP相同 ,则表示匹配成功 ,成功转发 ,否则不能转发。

```yml
spring:
  application:
    name: dudu-gateway
  cloud:
    gateway:
      routes:
        - id: weixin_route #
          uri: http://www.javaqf.com/
          predicates:
          - RemoteAddr=127.0.0.1
```



## Gateway基于服务发现路由



前面学习了Spring Cloud Gateway的Predict（断言），其中在对服务路由转发的这一块，是采用硬编码的方式进行路由转发。接下来将学习Spring Cloud Gateway如何配合服务注册中心进行路由转发。

#### pom引入Eureka

在gateway工程中引入项目所需的依赖，包括eureka-client的起步依赖和gateway的起步依赖

```xml
      <!--Spring Cloud gateway Start -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>
        <!--Spring Cloud gateway End -->
        <!--Spring Cloud Eureka Start -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <!--Spring Cloud Eureka End -->
```

#### application.yml

```yml
server:
  port: 8000
spring:
  application:
    name: dudu-gateway
  cloud:
    gateway:
      routes:
        - id: dudu-user
          uri: lb://DUDU-USER
          predicates:
            - Path=/dudu-user/**
#eureka config
eureka:
  client:
    service-url:
      defaultZone: http://localhost:9001/eureka/
```



在上面的配置中，配置了一个Path 的predict,将以/dudu-user/**开头的请求都会转发到uri为lb://DUDU-USER的地址上，lb://DUDU-USER即service-hi服务的负载均衡地址，并在转发之前将/dudu-user去掉。

```xml
正确访问路径：
http://localhost:8000/dudu-user/user/1
```



#### 高级配置

**spring.cloud.gateway.discovery.locator.enabled为true**

```
表明gateway开启服务注册和发现的功能，并且spring cloud gateway自动根据服务发现为每一个服务创建了一个router，这个router将以服务名开头的请求路径转发到对应的服务。
```

**spring.cloud.gateway.discovery.locator.lower-case-service-id为true**

```
是将请求路径上的服务名配置为小写（因为服务注册的时候，向注册中心注册时将服务名转成大写的了），比如以/service-hi/*的请求路径被路由转发到服务名为service-hi的服务上。
```

```yml
server:
  port: 8000
spring:
  application:
    name: dudu-gateway
  cloud:
    gateway:
      discovery:
        locator:
          lower-case-service-id: true
          enabled: true

eureka:
  client:
    service-url:
      defaultZone: http://localhost:9001/eureka/
```

访问成功：

```
http://localhost:8000/dudu-user/dudu-user/user/1
http://localhost:8000/dudu-meeting/dudu-meeting/meetingpub/02372a1b-5aa7-4333-abe0-55899b5c74b7
```

