1. # 数据库设计三大范式

   第一范式（确保每列保持原子性）

   第一范式是最基本的范式，如果数据库中的所有字段值都是不可分解的原子值，就说明该数据库满足了第一范式

   

   第二范式（确保每列都和主键相关）

   第二范式在第一范式的基础上更上一层，第二范式需要确保数据库中的每一行数据都和主键相关，而不能只与主键的某一部分相关，每一张表中只能存储一种数据，不能和其他的多种数据同存一张表上

   

   第三范式（确保每列都和主键直接相关，而不是间接相关）

   第三范式需要确保数据表中的每一列数据都和主键直接相关，而不是间接相关

1. # 数据库常见公共字段

   主键id

   排序字段

   当前时间

   更新时间

   操作用户

   更新用户

   状态值

1. # DTO VO PO 的区别

   DTO 数据传输对象 是经过处理的的PO，可能增加或减少PO的属性：Data Transfer Object数据传输对象（服务层需要的数据）

   

   VO 视图对象 主要体现在视图对象，对于一个WEB页面将整个页面的属性封装成一个对象。然后使用一个VO对象在控制层与视图层进行传输交换（展示层需要的数据）

   

   PO persistent object 持久化对象 它跟持久化层的数据结构形成一一对应的关系，如果持久化层是关系型数据库，那么数据表中的每个字段就对应PO的一个属性

   

2. # JAVA常用编码规范（说5个）

   ```
   参考阿里巴巴编码规范
   代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。
   代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。
   杜绝完全不规范的缩写，避免望文不知义。
   任何二目、三目运算符的左右两边都需要加一个空格。
   代码缩进要用4个空格，而不是用tab键进行缩进
   ```

3. # 软件开发生命周期

   问题定义

   可行性分析

   总体描述

   系统设计（架构设计/数据库设计）

   编码（开发）

   调试与运行（测试）

   验收与运行

   （维护升级/版本迭代）

   

# Nginx晨考题

1. ## 高可用、高并发、高性能概述

   高并发：通过设计保证系统能够同时并行处理很多请求

   高可用：系统通过设计从然减少停工时间，而保持其他服务的高度可用行

   高性能：指服务响应块，特别在高并发下响应时间不会急剧增加

2. ## 什么是Nginx

   Nginx是一款轻量级的Web服务器，反向代理服务器及电子邮件代理服务器。

3. ## Nginx应用场景

   1静态资源服务

   2反向代理

   3负载均衡

4. ## 正向代理和反向代理区别

   正向代理：是请求方请求一个代理服务器来获得目标服务器的数据。

   反向代理：反向代理是目标服务器自己请求另一个地址来获取数据。

5. ## 长连接和短连接区别

   长连接：客户端和服务器进行连接，且链接不会关闭，不管进行多少次交互都不会关闭，只有客户端关闭了之后他们的连接才会中断

   短链接：客户端和服务器进行连接，当客户端与服务器交互交互一次之后连接关闭。

6. ## HTTP和HTTPS的区别

   HTTP：HTTP是网络传输协议，HTTP传输的数据都是明文传输的，比起HTTPS是不安全的，但是HTTP的传输效率高

   HTTPS:HTTPS也是网络传输协议，HTTPS传输的数据是经过加密的，比起HTTP协议来说，HTTPS是安全的，但是他的效率要低于HTTP协议

7. ## 什么是集群

   集群就是将一个业务部署在多个服务器上。

8. ## 什么是负载均衡

   负载均衡是高可用网络架构的一个关键部分，将请求方的请求分配到不同的服务器上用来提高网站，应用，数据库或其他服务的性能以及可靠性

9. ## Nginx负载均衡的规则有哪些

   轮询

   指定轮询

   ip_hash

   url_hash

   fair

10. ## 集群分布式Session解决方案·

Session保持

Session复制

Session共享



1. ##  JAVA中集合和数组的区别

   数组的特点：数组的大小是固定的

   集合的特点：大小是可以动态扩展的

2. ## Collection和Collections的区别

   Collection是一个集合的接口，它提供了集合对象进行基本操作的通用方法。

   Collections是一个包装类。它包含了有关集合操作的多种静态方法，且不能实列化，用于对集合的排序，搜索及线程安全等各种操作。

3. ## ArrayList和LinkedList 和Vector的区别

   ArrayList是一个可变大小的数组，当有更多数据插入的时候，数组的大小是动态增长的，内部的元素可以通过get，set方法进行访问

   LinkedList是一个双向链表，在添加删除元素的时候效率要高于ArrayList，但是查询的要低于ArrayList

   Vector和ArrayList一样是动态数组，但是Vector是线程安全的，而ArrayList是线程不安全的，但是ArrayList的性能要比Vector要好

4. ## list/set/map的区别

   list继承与collection接口，list是有序的，每一个元素都是有一个索引索引下标从0开始。且元素是可以重复的。

   set继承于collection接口，元素的没有顺序的，存储的元素的不能重复的，可以存一个null值

   map是键值对存储数据的，key和value是一一对应的关系，在map中key是不可以重复的，但是value值是可以重复的

5. ## HashSet和TreeSet和LinkedHashSet区别

   hashset其内部是以hashcode来实现的，集合元素可以有一个null值。它内部元素的顺序是由hashcode决定的，所以它不保证set的迭代顺序；

   treeset是二叉树实现的，基于TreeMap来实现，不允许放入null值。它是使用元素的自然的自然顺序对元素进行排序

   LinkdeHashSet同样是根据元素的hashcode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。当遍历该集合时，将会以元素的添加顺序访问集合的元素。

6. ## HashMap和HashTable的比较

   HashMap是线程不安全的，HashTable是线程安全的

   HashTable不允许null值，HashMap只是允许有一个null值

   两者的遍历方式大同小异，HashTable仅仅比HashMap多一个elements方法

7. ## HashMap和ConcurrentHashMap区别

   HashMap是线程不安全的

   ConcurrentHashMap是线程安全的，但是它和HashTable不一样，它是实现分段锁来实现线程安全的，通过key的hash决定将数值存在那个分段上的。

8. ## HashMap 底层实现原理

   HashMap底层是由动态数据加链表和红黑树的结构来存储数据的

   当插入的数据达到数组的负载因子0.75时，数组就会自动扩容

   当发生hash碰撞的时候，相同hash值的数据会以链表的形式存储在相同的index上。当大于8的时候会自动转化为红黑树

9. ## HashMap和LinkedHashMap的区别

   hashmap内部维持了一个动态数组存储数据是没有顺序的，且允许有一个键值为null

   LinkedHashMap内部维持了一个双向链表取值的顺序是和存值的顺序是一样的，且键值对不能为null




# HashMap实现原理

## 一、什么是Hash?

> 定义：也称散列、哈希。
>
> 就是把任意长度的输入，通过HASH算法变成固定长度的输出。
>
> 哈希值：原始数据通过HASH映射后的二进制就是哈希值

## 特点：

> 1. Hash值 不可逆（不可恢复成原文）。 
>
> 2. 输入数据经过微小的变化得到不同的HASH值
>
> 3. 相同的数据会得到相同的HASH值
>
> 4. hash算法执行效率很高。很长的文本也能快速计算得到HASH值
>
> 5. hash算法的冲突概率很小
>
>    ```
>    hash  非固定的文本--》生成固定大小 【抽屉原理】
>    ```

## 二、什么是Hash冲突（碰撞）?

> 定义：如果两个输入串的hash值一样，则称就是hash碰撞。
>
> （把任意长度的输入，通过HASH算法变成固定长度的输出）
>
> ### 解决Hash冲突问题？
>
> ```
> 开放寻址法、
> 链接法（键表法）
> 把所有结点（key得到hash值）存入在散列表中。通过链表（Linked)关联
> ```
>
> 

## 三、HashMap数据结构?

> 数据+链表+红黑树

## 四、什么是红黑树？

> 红黑树：是一种自平衡二叉查找树
>
> 根节点是黑色。节点是红色和黑色

## 五、HashMap常用知识点（源代码）

> 默认初始容量：16.(位移运算)  个数太多或太少？ 太少：容易产生扩容。如果太多，遍历HASH表会很慢
>
> 最大容量：1<<30
>
> 加载因子：0.75f
>
> HashMap 懒汉式（只有PUT的时候才会构建）

## 什么时候HASHMAP转成红黑树

> 链表长度>=8时，有可能会转成树结构
>
> 链表转换成树之前，还会有一次判断，数组的长度大于64 才会发生转换。

> ArrayList初始值大小多少，add之后多少
>
> LinkedList..
>
> HashMap...





```bat
/*
每个解决方案的产生一定因为之前发生了问题（需要改变)
  数组：
    定义：相同数据类型的集合。
    特点：长度固定、下标索引
  集合：
    定义：相同数据类型的集合。
    特点：长度可变的，下标索引查询
 List
    Vector: 线程安全（底层基于数组）
    ArrayList:线程不安全
    基于数组、查询效率高。
    Vector和ArrayList区别？
    缺点：删除效率低
    优点：查询效率高
    LinkedList:
     链表结构
      优点：删除效率高、添加效率高。
      缺点：查询效率低

    ArrayList和LinkedList区别？

  list和set的区别?
    List:有序、允许重复
    Set:无序、不允许重复。

 Set （基本：无序、去重）   无序：插入的顺序和取出顺序不一致。
  HashSet:无序、去重
  TreeSet:有序 TreeMap(红黑树）
  LinkedHashSet:有序（链表）
 问题：数据结构查询效率高、 链表结构增删效率高？有没有一种数据结构（集合）查询效率高、增删效率高？
 Map：(key,value)
  HashMap和HashTable的区别？


 */
```







# Redis晨考

1. ## Redis是什么？

   redis是完全免费的，遵循BSD协议，是一个高性能的NOSQL的key-value数据库

2. ## NOSQL是什么，出现的目的和意义是什么？

   NoSQL，泛指非关系型的数据库，NoSQL即Not-Only SQL，它可以作为关系型数据库的良好补充

3. ## Redis的优点和缺点？

   优点：性能高：每秒的读写次数非常高

   ​			丰富的数据类型：String，Hash，List,Set等等

   ​			原子性：所有的操作都是原子性的，要么成功，要么失败

   ​			丰富的特性：支持publish、subscribe，key过期等等

   缺点：持久化：数据在内存中，不安全，要定时进行快照

   ​			消耗内存：所有的数据都存在内存中

4. ## Redis有哪些应用场景？为什么要学习Redis

   用在缓存，排行榜， 计数器，分布式会话，分布式锁，社交网络，最新列表，消息系统等等

   

   为什么学redis：性能高，丰富的数据类型，原子性，丰富的特性

   

5. ## Redis在什么情况下会进行持久化操作？

   SAVE命令持久化

   自动触发持久化 save 900 1，save 300 10 等等

   shutdown正常关闭的时候

6. ## Redis内存维护策略？

   1设置过期时间

   2采用LRU算法动态将不用的数据删除：volatile-lru   allkeys-lru等等

7. ## 描述一个最熟悉的设计模式（除单例、工厂）

   中介者模式是用来降低多个对象和类之间的通信复杂性，这种模式提供了一个中介类，该类通过处理不同类之间的通信，并支持解耦合，使代码易于维护，中介者模式属于行为型模式。

   

8. ## TCP和UDP区别

   | TCP              | UDP              |
   | ---------------- | ---------------- |
   | 面向有链接的     | 面向无连接的     |
   | 面向字节流       | 基于数据报的     |
   | 保证数据的正确性 | 可能丢包         |
   | 保证数据的顺序   | 不保证数据的顺序 |
   | 效率低           | 效率高           |

   

9. ## 描述TCP的三次握手和四次挥手过程

第一次握手：客户端发送syn报文，服务端收到，客户端可发送，服务端可接收

第二次握手：服务端收到后发送syn+ack报文给客户端，客户端了解到===》客户端和服务端都能接收和发送

第三次握手：客户端发ack报文，服务器收到。服务器了解到==》客户端接收服务器接收都是正常的。



第一次挥手：客户端发送一个fin报文给服务器，并停止再发送数据，等待服务器确认

第二次挥手：服务器接收到客户端发送的fin报文，给客户端发送一个ack报文，等待客户端确认。此时TCP处于半关闭状态。

第三次挥手：服务器想要断开，给客户端发送一个fin报文，等待客户端确认

第四次挥手：客户端收到服务器发送的fin报文，客户端发送一个ack报文回应，服务器接收到了之后就会关闭连接。







1. ## 什么是线程？线程和进程的区别？

   线程是操作系统能够进行运算调度的最小单位，他被包含在进程之中，是进程的实际运行单位。

   区别：1线程在进程之中进行运行

   ​			2一个进程可以包含多个线程

   ​			3不同进程间的数据很难共享

   ​			4统一进程下的线程信息很容易共享

   ​			5进程要比线程多.更消耗计算机资源

   ​			6进程之间不会有影响，但是一个线程挂掉将会导致整个进程挂掉

   ​			7进程使用的地址可以上锁

2. ## 描述CPU和多线程的关系

   CPU一般是多少核多少线程的。其中的核心数是cpu物理概念

   线程是cpu的模拟出来的，一个cpu核心能模拟出来2个核心数，那么一个cpu核心就能同时处理两个任务。

   cpu的核心数越多那么他的线程数也就越多，处理多线程的进程的能力就会越强。(CPU调用线程)

3. ## 什么是线程安全/线程不安全？

   线程安全：指的是多个线程在执行同一代码的时候采用加锁机制，使每次执行的结果和单线程值行的结果是一样的，不存在执行线程出现意外结果

   线程不安全：是指不提供加锁机制的保护，有可能出现多个线程先后更改数据造成得到的数据是脏数据

4. ## 描述下线程的生命周期？（画图）<img src="D:\FeiQ\五阶段\1584064711274.png" />

5. ## wait、sleep、join、yield的区别

   wait方法是属于Object类中的，wait的过程中会释放对象锁，只有其他线程调用notify方法的时候才能唤醒此线程

   sleep方法属于thread方法，sleep的过程中是不会释放对象锁的，只会阻塞线程，让出cpu给其他的线程。当时间到了该线程就会进入就绪状态，等待cpu的调用

   join等待调用join方法的线程结束之后，程序在继续执行，一般用于等待异步线程执行完结果之后才能继续运行的场景。

   yield和sleep一样都是Thread方法，都是暂停当前正在执行的线程对象，不会释放资源锁，和sleep不同的是yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态

6. ## Synchronized和Lock的区别

   | 类别       | synchronized                                                 | lock                                     |
   | ---------- | ------------------------------------------------------------ | ---------------------------------------- |
   | 存在层次上 | Java的关键字，在jvm层面上                                    | 是一个类                                 |
   | 锁的获取   | 使用synchronized的关键字获取锁                               | 使用lock方法来获取锁                     |
   | 锁的释放   | 1获取锁的线程执行完，自动释放锁。<br />2当获取锁的线程抛出异常的时候，jvm会制动释放锁 | 必须使用unlock方法来释放线程锁获得的锁。 |
   | 锁状态     | 无法判断                                                     | 可以判断                                 |
   | 锁类型     | 可重入，不可中断，非公平                                     | 可重入，可判断，可公平                   |
   | 性能       | 少量同步                                                     | 大量同步                                 |

   

7. ## ThreadLocal、Volatile、Synchronized 的作用和区别

   Volatile主要是用来在多线程中同步变量。

   ThreadLocal是一个线程的局部变量(其实就是一个Map),ThreadLocal会为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。

   synchronized关键字是Java利用锁的机制自动实现的，一般有同步方法和同步代码块两种使用方式。

8. ## 同步方法和同步块，个更好?

   同步块是更好的选择，因为它不会锁住整个对象。同步方法会锁住整个对象。

   同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。

9. ## 什么是死锁？如何避免死锁？

   死锁：当两个线程相互等待对方释放资源时，就会发生死锁。

   避免死锁：1加锁顺序：当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生

   ​					2死锁检测：每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。

   ​					3加锁时限：尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。

10. ## 常见的线程池叫什么，线程池的作用是什么

    线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。

    newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

    newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

    newScheduledThreadPool 创建一个周期线程池，支持定时及周期性任务执行。

    newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO， LIFO， 优先级）执行。

    作用：

    1、重用线程池的线程，可以避免因为线程的创建和销毁锁带来的性能开销

    2、可以有效的控制线程池的最大并发数，避免线程之间因为抢占系统资源而阻塞

    3、可以对线程进行简单的管理，除此之外，还可以提供以下的特定操作，例：提供定时、定期、单线程、并发数控制等功能





# 作业

1. ## 详细描述什么是Spring?

   1spring的核心是一个轻量级的容器

   2spring是实现ioc容器和非侵入式的框架

   3spring提供aop概念的实现方式

   4spring提供持久化层和事务层的支持

   5spring供mvc web框架的实现，并对一些常用的企业服务api提供一致的模型封装

   6spring提供了对现存的各种框架相整合的方案

2. ## 什么是Spring IOC？

   ioc即控制反转，不是技术，而是一种设计思想。在java开发中，ioc意味着将你设计好的对象交给容器控制，而不是传统的在你对象内部进行控制。

   控制反转：控制：ioc容器对你的对象进行控制，控制它的创建和外部资源的获取

   ​					反转：自己创建对象的方式叫做正转，而容器创建好的对象，用户直接注入依赖叫反转。

   

3. ## 什么是Spring AOP?描述其应用场景（最少2个）

   面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。

   AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。

   场景：统一日志处理

   ​			事务

   ​			shiro权限

   ​			缓存

4. ## AOP的通知有几个，分别是什么

   前置通知

   后置通知

   返回通知

   异常通知

   环绕通知

5. ## 描述Spring Bean的作用域？

   bean就是ioc容器创建和管理的java对象。

   bean的作用域

   | 类别          | 说明                                                         |
   | ------------- | ------------------------------------------------------------ |
   | singleton     | 在spring ioc容器中仅存在一个bean的实列，bean以单例方式存在   |
   | prototype     | 每次从容器中调用bean时，都返回一个新的实列，即每次调用getBean时，相当于执行new xxxbean（） |
   | request       | 每次HTTP请求都会创建一个新的bean，该作用域仅作用于webapplicationcontext环境 |
   | session       | 同一个HTTP session共享一个bean，不同session使用不同bean仅适合用于----- |
   | globalSession | 一般用于Portlet应用环境，该作用域仅适合-----                 |

   

6. ## Spring Bean 注入有几种方式？  

   1set方法注入  在xml文件中set类中的属性（前提是提供了set方法）

   2构造方法注入 通过类的构造函数在xml文件中设置类的属性值

   3静态工厂注入 在xml文件中调用工厂类的方法进行对象的创建

   4实列工厂注入 在xml文件中先创建实列工厂对象，再对实列工厂里面的方法进行调用创建对象

7. ## SpringBean 生命周期？

   ##  <img src="https://upload-images.jianshu.io/upload_images/4558491-dc3eebbd1d6c65f4.png?imageMogr2/auto-orient/strip|imageView2/2/w/823/format/webp" alt="img" style="zoom: 80%;" />

8. ## Spring框架中 用到了哪些设计模式？（不低于3个）

   工厂模式

   单例模式

   代理模式（aop中实现）

   观察者模式

   适配器模式（spring aop和spring mvc中的适配器模式）

   装饰者模式

9. ## 描述Spring事务传播行为？

   事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法时事务如何传播。

   | 事务类型                      | 说明                                                         |
   | ----------------------------- | ------------------------------------------------------------ |
   | PROPAGATION_REQUIRED（依赖）  | 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。 |
   | PROPAGATION_SUPPORTS          | 支持当前事务，如果当前没有事务，就以非事务方式执行。         |
   | PROPAGATION_MANDATORY（强制） | 使用当前的事务，如果当前没有事务，就抛出异常。               |
   | PROPAGATION_REQUIRES_NEW      | 如果当前没有事务，新建事务，如果当前存在事务，把当前事务挂起。 |
   | PROPAGATION_NOT_SUPPORTED     | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。   |
   | PROPAGATION_NEVER（从不）     | 以非事务方式执行，如果当前存在事务，则抛出异常。             |
   | PROPAGATION_NESTED（嵌套）    | 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则新建事务 |

10. ## 描述Spring事务的隔离级别？

    ````
    1. 读已提交 -> READ-COMMITTED    -> 防止脏读
    2. 读未提交 -> READ-UNCOMMITTED  -> 不能保证数据安全
    3. 可重复读 -> REPEATABLE-READ   -> 可以防止脏读和不可重复读
    4. 串行化   -> SERIALIZABLE      -> 防止脏读、幻读、不可重复读,但是性能较差
    ````

    ```
    脏读 ：一个事务读取的数据是另一个事务没有来的及提交的数据
    幻读：同一事务中，用同样的操作读两次，得到的记录数不一样
    不可重复度：同一事务，两次读取同一条数据，得到的内容不一样
    ```

    

11. ## Spring事务传播行为 REQUIRED和REQUIRES_NEW区别

    ```
    PROPAGATION_REQUIRED  如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。
    PROPAGATION_REQUIRES_NEW    如果当前没有事务，新建事务，如果当前存在事务，把当前事务挂起。
    ```






1. ## SpringMVC中的Bean是线程安全的吗？ 说出你的解决方案？ 

   ```
   Spring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略，因此可以说Spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究。
   ```

   ```
   原型Bean
   对于原型Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。
   
   单例Bean
   对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。
   如果单例Bean,是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。
   对于有状态的bean，Spring官方提供的bean，一般提供了通过ThreadLocal去解决线程安全的方法，比如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等。
   注： Spring容器本身并没有提供线程安全的策略，因此是否线程安全完全取决于Bean本身的特性。
   ```

   ```
   使用ThreadLocal
   使得多线程场景下，多个线程对这个单例Bean的成员变量并不存在资源的竞争，因为ThreadLocal为每个线程保存线程私有的数据。
   ```

   

2. ## SpringMVC的执行

   <center>
   <img src="https://images2018.cnblogs.com/blog/1370903/201808/1370903-20180827201021158-682489195.png">
   </center>

3. ## @RequestMapping注解作用

   这个注解将HTTP请求映射到MVC和REST控制器的处理方法上。

4. ## @RequestBody 和@ResponseBody的区别

   RequestBody：将前端传送来的值以json字符串类型接收

   ResponseBody：将方法的返回值以json字符串的形式输出

5. ## @RequestParam和@PathViriable的区别

   两者的功能是相似的，都是接收传来的请求，然后将url中的参数绑定到方法的入参上。

   前者的方法是url以参数的方式进行绑定

   后者是将数据以url地址的方式进行绑定

6. ## @Resource和 @Autowired/ @Qualifier的区别

   @Autowired：是根据类型注入

   @Resource：根据名称注入

   @Autowired ：@Qualifie("dogServiceImpl") 两个结合起来可以根据名字和类型注入

7. ## @Controller, @Service, @Repository,@Component作用

   component是将类加入到ioc容器中

   以下的所有注解都是含有component的

   Controller是将打上此注解的类表明为控制层

   Service是将打上该注解的类表明为服务层

   Repository是将打上该注解的类表明是持久化层

8. ## @Transactional注解作用

   该注解是将所加上的类或者方法啊加上事务管理，一旦出现异常或者错误就会中断操作并且回滚。

   以aop的形式加入到容器中

9. ## @Configuration注解作用 (类上方声明)

   @Configuration用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。





# 机试作业题

利用Redis常用命令，完成奥运 奖牌排行榜

http://match.2008.sina.com.cn/bj2008/all_medal.php

| 国家 | 金牌 | 银牌 | 铜牌 | 总数 |
| ---- | ---- | ---- | ---- | ---- |
| 中国 | 12   | 9    | 8    |      |
| 美国 | 12   | 8    | 8    |      |
| 德国 | 10   | 7    | 6    |      |



# Redis晨考题

1. ## String类型常用命令（5个）、应用场景(2个)

   ```
   创建/赋值 set  key  value
   创建会过期的 key setex  key  time  value
   创建/自增key  incrby  key
   创建/自减key decr  key
   获取key   get key
   ```

   1、**因String是二进制安全的，所以你完全可以把一个图片文件的内容作为字符串来存储**

   2、**计数器（常规key-value缓存应用。常规计数: 微博数, 粉丝数)**

   

2. ## Hash类型常用命令（5个）、应用场景(2个)

   ```
   创建hash类型的key  hset key value
   获取所有哈希表中的字段  HKEYS KEY  
   获取哈希表中字段的数量  HLEN KEY 
   删除一个或多个HASH表字段   HDEL KEY field1[field2] 
   为哈希表 key 中的指定字段的整数值加上增量 increment  HINCRBY key field increment 
   
   ```

   1、**存对象**

   2、**用户注册/修改信息**

3. ## List类型常用命令（5个）、应用场景（2个）

   	LPUSH key value1 [value2]  :将一个或多个值插入到列表头部(从左侧添加)
   	RPUSH key value1 [value2]  :在列表中添加一个或多个值(从右侧添加)
   	LINDEX key index   :通过索引获取列表中的元素
   	LRANGE key start stop  :获取列表指定范围内的元素
   	LPOP key  移出并获取列表的第一个元素(从左侧删除)
   	RPOP key  移除列表的最后一个元素，返回值为移除的元素(从右侧删除)

   **项目常应用于：1、对数据量大的集合数据删减 2、任务队列** 

4. ## Set类型常用命令(5个)、应用场景（2个）

   ```
   SADD key member1 [member2] :向集合添加一个或多个成员 
   SMEMBERS key  :返回集合中的所有成员 
   SISMEMBER key member  :判断 member 元素是否是集合 key 的成员
   SREM key member1 [member2] :移除集合中一个或多个成员
   SPOP key [count]  :移除并返回集合中的一个随机元素
   ```

   1，**抽奖活动**

   2，**判断用户是否存在**

5. ## ZSet类型常用命令(5个)、应用场景（2个）

   ````
   ZADD key score1 member1 [score2 member2]  :向有序集合添加一个或多个成员，或者更新已存在成员的分数  
   ZCOUNT key min max :计算在有序集合中指定区间分数的成员数
   ZRANK key member :返回有序集合中指定成员的索引
   ZRANGE key start stop [WITHSCORES] :通过索引区间返回有序集合成指定区间内的成员(低到高)
   ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] :通过分数返回有序集合指定区间内的成员
   ````

   1,**排行榜**

   2,**阅读量**

6. ## Redis持久化RDB和AOF区别

   RDB：是创建一个rdb的文件，当redis出发快照机制的时候，将数据存进rdb文件中。但是在服务器宕机的时候，在没有快照的那段时间的数据将会丢失。

   AOF：是将redis的写操作进行存储在aof文件中，虽然这个操作不会使数据丢失，但是aof文件中的写操作大多都是没用的，每次启动的时候都会进行一些没有意义的操作。

7. ## Redis缓存和数据库一致性（工作中是如何将Redis和数据库数据进行同步的）

   1实时同步，在缓存中查询，当查不到的时候就去DB中查询，再将其加入到缓存中

   2异步队列，使用kafka/rabbitMQ消息队列将数据消化

   3使用阿里的同步工具canal

   4采用udf自定义函数的方式

8. ## 缓存穿透是什么，解决方案、原因

   **缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。**

   持久层查询不到就缓存空结果，查询时先判断缓存中是否exists(key) ,如果有直接返回空，没有则查询后返回，
   注意insert时需清除查询的key，否则即便DB中有值也查询不到(当然也可以设置空缓存的过期时间）

   ​		1、不管数据实际上存不存在，我们都把这个键存到缓存中（有效期设置的短一些，比如一分钟到三分钟），然后值设置为一个特定值，业务中如果获取到的结果是这个特定值，则报错返回。

   ​		2、是使用 redis 的布隆过滤器（Bloom Filter），将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

   

9. ## 缓存雪崩是什么，解决方案、

   **雪崩：缓存大量失效的时候，引发大量查询数据库。**

     用锁/分布式锁或者队列串行访问
   	缓存失效时间均匀分布

10. ## 热点KEY处理，（缓存击穿）

    **热点key:某个key访问非常频繁，当key失效的时候有大量线程来构建缓存，导致负载增加，系统崩溃。**

    1 使用锁，单机用synchronized,lock等，分布式用分布式锁。

    2 缓存过期时间不设置，而是设置在key对应的value里。如果检测到存的时间超过过期时间则异步更新缓存。

    3在value设置一个比过期时间t0小的过期时间值t1，当t1过期的时候，延长t1并做更新缓存操作。

    4设置标签缓存，标签缓存设置过期时间，标签缓存过期后，需异步地更新实际缓存 







1. ### 什么是MyBatis?

   ```
   1. 是一款优秀的持久层框架
   2. 支持定制化sql，存储过程以及高级映射
   3. 可以避免几乎所有的JDBC代码手动设置参数以及获取结果集
   4. 可以使用简单的 XML 或注解来配置和映射原生信息
   5. 用接口将Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录
   ```

   

2. ### #{}和${}的区别是什么？  *应用场景*

   ```
   #{} ： 根据参数的类型进行处理，比如传入String类型，则会为参数加上双引号。#{} 传参在进行SQL预编译时，会把参数部分用一个占位符 ? 代替，这样可以防止 SQL注入。
   ${} ： 将参数取出不做任何处理，直接放入语句中，就是简单的字符串替换，并且该参数会参加SQL的预编译，需要手动过滤参数防止 SQL注入。
   ```

   ```
   因此 mybatis 中优先使用 #{}；当需要动态传入 表名或列名时，再考虑使用 ${} 。
   
   其中 ${} 比较特殊， 他的应用场景是 需要动态传入 表名或列名时使用。
   ```

   

3. ### 在mapper中如何传递多个参数，都有哪几种

   ```
   第1种：使用Java对象，在映射文件中使用#{0}，#{1}代表传递进来的第几个参数。
   第3种: 使用@param注解:来命名参数
   第3种：使用Map集合作为参数来装载
   ```

   

4. ### 说出MyBatis动态标签（至少5个）

   ```
   if
   set
   choose
   foreach
   where
   ```

   

5. ### parameterType和resultType的区别

   ```
   parameterType是规定入参和入参类型的标签
   resultType是规定返回值的类型的标签
   ```

   

6. ### 在用MyBatis插入时，如何得到数据库自增的主键值？

   ```
   在mybatis的XML文件时，配置useGeneratedKeys和KeyProperty属性，且这两个属性不能省略。
   useGeneratedKeys属性，要求数据库本身具备主键自动增长的功能。
   KeyProperty属性，java对象的属性名，也就是要获取的字段。
   ```

   

7. ### MyBatis批量删除时，请问如何实现？

   ```
    <!-- 批量删除 -->
    <delete id="batchDeleteUsers">
    	DELETE FROM user WHERE user_id IN 
    	<foreach collection="list" item="id" open="(" separator="," close=")">
    		#{id}
    	</foreach>
    </delete>
   ```

   

8. ### MyBatis批量添加时，请问如何实现？

   ```
   <insert id="batchAddUser" parameterType="user">
    	INSERT INTO user(user_name,create_time) VALUES 
    	<foreach collection="list" item="item"  separator="," >
    		(#{item.userName},#{item.createTime})
    	</foreach>
    </insert>
   ```

   

9. ### MyBatis动态SQL执行流程和原理

   ```
   1.SqlResource 该接口含义是作为sql对象的来源，通过该接口可以获取sql对象。其唯一的实现类是XmlSqlResource，表示通过xml文件生成sql对象。
   2.Sql 该接口可以生成sql语句和获取sql相关的上下文环境(如ParameterMap、ResultMap等)，有三个实现类: RawSql表示为原生的sql语句，在初始化即可确定sql语句；SimpleDynamicSql表示简单的动态sql，即sql语句中参数通过方式指定，参数在sql生成过程中会被替换，不作为sql执行参数；DynamicSql表示动态sql，即sql描述文件中包含isNotNull等条件标签。
   3.SqlChild 该接口表示sql抽象语法树的一个节点，包含sql语句的片段信息。该接口有两个实现类: SqlTag表示动态sql片段，即配置文件中的一个动态标签，内含动态sql属性值(如prepend、property值等)；SqlText表示静态sql片段，即为原生的sql语句。每条动态sql通过SqlTag和SqlText构成相应的抽象语法树。
   4.SqlTagHandler 该接口表示SqlTag(即不同的动态标签)对应的处理方式。比如实现类IsEmptyTagHandler用于处理标签，IsEqualTagHandler用于处理标签等。
   5.SqlTagContext 用于解释sql抽象语法树时使用的上下文环境。通过解释语法树每个节点，将生成的sql存入SqlTagContext。最终通过SqlTagContext获取完整的sql语句。
   ```

   

10. ### JDBC为什么比Mybatis效率快？

    ```
    mybatis底层终究是调用jdbc的。而映射这东西不管是对象转一些值，还是一些值转对象，都需要调用反射api的
    ```

    

11. ### MyBatis框架中用到了哪些设计模式？（3个）

    ```
    工厂模式
    单例模式
    代理模式
    适配器模式
    装饰者模式
    ```

    

12. ### 缓存穿透是什么，解决方案、原因

    ```
    缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。
    
    持久层查询不到就缓存空结果，查询时先判断缓存中是否exists(key) ,如果有直接返回空，没有则查询后返回，
    注意insert时需清除查询的key，否则即便DB中有值也查询不到(当然也可以设置空缓存的过期时间）
    
    1、不管数据实际上存不存在，我们都把这个键存到缓存中（有效期设置的短一些，比如一分钟到三分钟），然后值设置为一个特定值，业务中如果获取到的结果是这个特定值，则报错返回。
    2、是使用 redis 的布隆过滤器（Bloom Filter），将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
    ```

    

13. ### 缓存雪崩是什么，解决方案、

    ```
    雪崩：缓存大量失效的时候，引发大量查询数据库。
    
    用锁/分布式锁或者队列串行访问
    缓存失效时间均匀分布
    ```

    

14. ### 热点KEY处理，（缓存击穿）

    ```
    热点key:某个key访问非常频繁，当key失效的时候有大量线程来构建缓存，导致负载增加，系统崩溃。
    
    1 使用锁，单机用synchronized,lock等，分布式用分布式锁。
    
    2 缓存过期时间不设置，而是设置在key对应的value里。如果检测到存的时间超过过期时间则异步更新缓存。
    
    3在value设置一个比过期时间t0小的过期时间值t1，当t1过期的时候，延长t1并做更新缓存操作。
    
    4设置标签缓存，标签缓存设置过期时间，标签缓存过期后，需异步地更新实际缓存 
    ```

    

15. ### Redis集群特点

    ```
    1、所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。
    2、节点的fail是通过集群中超过半数的节点检测失效时才生效。
    3、客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。
    4、redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配）,cluster 负责维护
    5、Redis集群预分好16384个哈希槽，当需要在 Redis 集群中放置一个 key-value 时， redis 先对key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节
    ```

    

16. ### Redis集群什么时候master不能用？

    ```
    当集群中大部分的redis服务器都挂掉后master不能用
    ```

    

17. ### 什么时候整个Redis集群不可用？

    ```
    a:如果集群任意master挂掉,且当前master没有slave.集群进入fail状态,也可以理解成集群的slot映射[0-16383]不完成时进入fail状态. 
    b:如果集群超过半数以上master挂掉，无论是否有slave集群进入fail状态.
    ```

    

15redis的key清除策略

```
惰性策略：当我们在访问过期key的时候，redis会判断此key是否过期，然后删除
定期策略：过一段时间只会对整个数据库进行遍历，然后删除过期key
内存淘汰机制：当内存大于maxmemory时，会对空间进行回收。
```





# Mysql晨考题

1. ## 描述主键、外键、候选主键、超键是什么

   ```
   主 键：
   数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。
   超 键：
   在关系中能唯一标识元素的属性集称为关系模式的超键。
   候选键：
   是最小超键，即没有冗余元素的超键。
   外 键：
   在一个表中存在的另一个表的主键称此表的外键。
   ```

   

2. ## 数据库设计的三大范式

   ```
   第一范式（1NF）：确保每列保持原子性即列不可分
   第二范式（2NF）：属性完全依赖于主键（属性都是该对象拥有的）
   第三范式（3NF）:属性和主键不能间接相关（减少数据冗余，这样就可以通过主外键进行表之间连接）
   ```

   

3. ## drop,delete与truncate的区别

   ```
   1、drop (删除表)：删除内容和定义，释放空间。简单来说就是把整个表去掉.以后要新增数据是不可能的,除非新增一个表。
   2、truncate (清空表中的数据)：删除内容、释放空间但不删除定义(保留表的数据结构)。与drop不同的是,只是清空表数据而已。
   3、delete (删除表中的数据)：delete 语句用于删除表中的行。delete语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。
   truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）
   ```

   

4. ## SQL UNION 和 UNION ALL 区别

   ```
   UNION 并集，表中的所有数据，并且去除重复数据并排序（工作中主要用到的是这个）；
   UNION ALL，表中的数据都罗列出来；
   ```

   

5. ## exists、in、any、all区别 

   ```
   EXISTS 只要遇到第一个满足条件的记录就马上返回(true,false)
   IN 操作符允许我们在 WHERE 子句中规定多个值
   ANY关键字表示满足其中任意一个条件。使用ANY关键字时，只要满足内层查询语句返回的结果中的任意一个，就可以通过该条件来执行外层查询语句
   ALL关键字表示满足所有条件。使用ALL关键字时，只有满足内层查询语句返回的所有结果，才可以执行外层查询语句
   ```

   

6. ## sql语句的执行顺序

   ```
   from 
   join 
   on 
   where 
   group by(开始使用select中的别名，后面的语句中都可以使用)
   avg,sum.... 
   having 
   select 
   distinct 
   order by
   limit 
   ```

   

7. ## count(*)和count(1)和count(id)区别

   ```
   count是数据库中的聚合函数，表示查找数据库中的个数。
   COUNT(1) 和 COUNT(*)表示的是直接查询符合条件的数据库表的行数
   而COUNT(列名/字段)表示的是查询符合条件的列的值不为NULL的行数。
   效率：count(1)>count(*)>count(id)
   ```

   

8. ## SQL语句优化（不少于6条）

   ```
   避免在WHERE子句中使用in，not in，or 或者having；
   可以使用 exist 和not exist代替 in和not in；对连续数值可以使用between；
   可以使用表链接代替 exist；
   Having可以用where代替，如果无法代替可以分两步处理。
   应尽量避免在where子句中对字段进行函数操作；
   尽量避免在 where 子句中对索引字段进行计算操作；
   应尽量避免在 where 子句中使用 != 或 <> 操作符；
   应尽量避免在 where 子句中对字段进行 null 值判断；
   应尽量避免在 where 子句中使用 or 来连接条件；
   否则将导致引擎放弃使用索引而进行全表扫描
   ```

   

9. ## SQL常用函数有哪些？

   ```
   AVG(col)返回指定列的平均值
   COUNT(col)返回指定列中非NULL值的个数
   MIN(col)返回指定列的最小值
   MAX(col)返回指定列的最大值
   SUM(col)返回指定列的所有值之和
   GROUP_CONCAT(col) 返回由属于一组的列值连接组合而成的结果
   NOW()    返回当前的日期和时间
   QUARTER(date)   返回date在一年中的季度(1~4)，如SELECT QUARTER(CURRENT_DATE);
   WEEK(date)   返回日期date为一年中第几周(0~53)
   YEAR(date)   返回日期date的年份(1000~9999)
   ```

   

10. ## 左连接 右连接 内连接的区别

    ```
    left join （左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。
    right join （右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。
    inner join （等值连接或者叫内连接）：只返回两个表中连接字段相等的行。
    ```

    

11. # Mysql三种常见引擎的区别

    | 特性           | InnoDB | MyISAM | MEMORY |
    | -------------- | ------ | ------ | ------ |
    | 事物安全       | 支持   | 不支持 | 不支持 |
    | 对外建的支持   | 支持   | 不支持 | 不支持 |
    | 存储限制       | 64TB   | 有     | 有     |
    | 空间使用       | 高     | 低     | 低     |
    | 内存使用       | 高     | 低     | 高     |
    | 插入数据的速度 | 低     | 高     | 高     |







1. ## mysql explain是什么？有什么作用？描述下type

   ```
   mysql explain的作用是模拟Mysql优化器是如何执行SQL查询语句的，从而知道Mysql是如何处理用户的SQL语句，提高数据检索效率，降低数据库的IO成本。
   type列：访问类型由好到差system > const > eq_ref > ref > range > index > ALL
   ```

   

2. ## mysql中有哪几种锁？表锁、行锁、页锁区别？

   ```
   行锁、表锁、页锁、悲观锁、乐观锁等
   （1）表级锁：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突的率最高，并发度最低
   （2）行级锁：开销大，加锁慢；会出现死锁；锁定力度最小，发生锁冲突的概率最低，并发度也最高。
   （3）页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定力度界于表 锁和行锁之间，并发度一般。
   ```

   

3. ## 悲观锁 乐观锁 的区别

   ```
   悲观锁
   每次拿数据都以为别人会修改，所以每次拿数据时都会上锁。
   实现：开启事务，启用锁机制
   乐观锁
   每次拿数据时候都认为别人不会修改，所以不会上锁，但是在更新数据时候会判断在此期间是否有人更新过。
   实现：1.使用版本号2.使用时间戳
   ```

   

4. ## 什么是索引？索引的种类有哪些，描述索引的优缺点?

   ```
   数据库索引是：数据库索引就像是一本书的目录一样，使用它可以让你在数据库里搜索查询的速度大大提升。
   索引是帮助MySQL高效获取数据的排好序的数据结构
   索引存储在文件里
   索引结构（索引底层的数据结构）（ 二叉树，红黑树， Hash， B-树）
   索引的几种类型分别是普通索引、唯一索引、聚集索引、主键索引、全文索引几种。
   
   二. 索引的优点
   索引能够提高数据检索的效率，降低数据库的IO成本。
   加速两个表之间的连接，一般是在外键上创建索引
   在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
   保证数据库表中每一行的数据的唯一性
   三. 索引的缺点
   在我们建立数据库的时候，需要花费的时间去建立和维护索引，而且随着数据量的增加，需要维护它的时间也会增加。
   索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，如果需要建立聚簇索引，那么需要占用的空间会更大
   以表中的数据进行增、删、改的时候，索引也要动态的维护
   ```

   

5. ## 设计索引的原则？(不少于4条)

   ```
   1．原则上表索引的个数不能超过5个；
   2．原则上单个字段上的索引不能超过2个；
   3．原则上复合索引引用的字段不能超过3个字段；
   4．原则上分区表的索引类型全部使用LOCAL索引；
   5．配置数据类的表，如数据量比较少，除了主键外原则上不建索引
   6．接口类和工单类的表，尽可能减少索引数量或者不建索引
   7．索引引用字段的顺序尽可能与使用该索引的查询中ORDER BY字段顺序保持一致
   ```

   

6. ## 什么情况下索引会失效？（不少于4条）

   ```
   1.对于创建的多列索引（复合索引），不是使用的第一部分就不会使用索引
   2.对于使用 like 查询， 查询如果是 ‘%aaa’ 不会使用索引，而 ‘aaa%’ 会使用到索引。
   3.如果条件中有 or， 有条件没有使用索引，即使其中有条件带索引也不会使用，换言之， 就是要求使用的所有字段，都必须单独使用时能使用索引。
   4.如果列类型是字符串，那么一定要在条件中使用引号引用起来，否则不使用索引。
   5.如果mysql认为全表扫面要比使用索引快，则不使用索引。
   ```

   

7. ## Btree和Hash区别

   ```
   Btree类型的索引，Btree又称b+树
   （1）所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；（只有根节点存储关键字最后树的末梢才有值)
   （2）非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层。（非根节点，存储的其实是指向根节点的索引）
   （3）不可能在非叶子结点存数据。
   （4）根节点横向也有链指针(方便快速顺藤摸瓜嘛，没这个指针，就算下一个取的值是挨着的邻居，也得跑个圈才能拿到)
   通过上述分析，所以能直观的理解出Btree类型在我们查询数据时适合用于范围查找，在某一叶子的节点到另一节点的范围。例如<,>,orderby等场景都可使用。
   
   
   Hash索引，其检索效率非常高的一种精确定位索引。
   Hash索引不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引，它会将计算出的Hash值和对对应的行指针信息记录在Hash表中。但是虽然Hash效率很高但是同样也有很多的弊端存在和限制存在。
   （1）Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。
   （2）Hash 索引无法被用来避免数据的排序操作。
   （3）Hash 索引不能利用部分索引键（组合索引）查询。
   （4）Hash 索引在任何时候都不能避免表扫描。
   （5）Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。
   ```

   

8. ## 数据库优化方案？（至少3条）

   ```
   1.对查询进行优化，要尽量避免全表扫描，首先应考虑在where 及 order by 涉及的列上建立索引。
   2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描
   3.应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描。
   4.应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描
   5.in 和 not in 也要慎用，否则会导致全表扫描
   6.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。
   ```

   

9. ## 什么是存储过程？有什么优缺点？

   ```
   就是一些编译好了的SQL语句，这些SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后给这些代码块取一个名字，在用到这个功能的时候调用即可。
   
   优点：
   1.存储过程是一个预编译的代码块，执行效率比较高
   2.存储过程在服务器端运行，减少客户端的压力
   3.允许模块化程序设计，只需要创建一次过程，以后在程序中就可以调用该过程任意次，类似方法的复用
   4.一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率
   5.可以一定程度上确保数据安全
   缺点：
   1.调试麻烦（没有像开发程序那样容易）
   2.可移植性不灵活（因为存储过程依赖于具体的数据库）
   ```

10. ## 什么是视图，视图有什么作用？

    ```
    视图(VIEW)也被称作虚表，即虚拟的表，是一组数据的逻辑表示,其本质是对应于一条SELECT语句，结果集被赋予一个名字，即视图名字。
    视图本身并不包含任何数据，它只包含映射到基表的一个查询语句，当基表数据发生变化，视图数据也随之变化。
    
    简单性。看到的就是需要的。视图不仅可以简化用户对数据的理解,也可以简化他们的操作。那些被经常使用的查询可以被定义为视图,从而使得用户不必为以后的操作每次指定全部的条件。 
    
    安全性。通过视图用户只能查询和修改他们所能见到的数据。但不能授权到数据库特定行和特定的列上。通过视图,用户可以被限制在数据的不同子集上:使用权限可被限制在另一视图的一个子集上,或是一些视图和基表合并后的子集上。 
    
    逻辑数据独立性。视图可帮助用户屏蔽真实表结构变化带来的影响。
    ```

    

11. ## 什么是分布式、微服务、集群？

    ```
    集群：同一个业务，部署在多个服务器上
    分布式：一个业务分拆多个子业务，部署在不同的服务器上
    微服务：一个业务分拆多个子业务，部署在不同的服务器上运行
    ```

12. ## SOA架构的优点和缺点

    ```
    优点：
    1、微服务对服务的拆分变更的更细（复用性强）。
    2、可根据需求使用新的技术
    3、开发速度快（周期少）。适用于互联网项目。
    缺点：
    微服务过多，对服务的治理成本高。
    服务的部署难度加大-->**（Docker-->k8s)**
    技术难点在增加（分布式事务......)
    ```

    

13. ## 分布式+微服务架构带来了新的技术新的问题？描述

    ```
    分布式事务   两(二）阶段提交
    分布式锁  Redis SETNX/Zookepper
    分布式Session  Spring Session(RedisCluster)
    分布式日志  elk
    分布式任务
    ```

    



```
Java的缺点
速度比较慢
内存溢出泄露不好处理（delete 对象 ;//释放资源）



Mybatiss的缺点
1. sql工作量很大，尤其是字段多、关联表多时，更是如此。
2. sql依赖于数据库，导致数据库移植性差。
3. 由于xml里标签id必须唯一，导致DAO中方法不支持方法重载。
4. 字段映射标签和对象关系映射标签仅仅是对映射关系的描述，具体实现仍然依赖于sql。（比如配置了一对多Collection标签，如果sql里没有join子表或查询子表的话，查询后返回的对象是不具备对象关系的，即Collection的对象为null）
5. DAO层过于简单，对象组装的工作量较大。
6.  不支持级联更新、级联删除。
7. 编写动态sql时,不方便调试，尤其逻辑复杂时。
8 提供的写动态sql的xml标签功能简单（连struts都比不上），编写动态sql仍然受限，且可读性低。
9. 使用不当，容易导致N+1的sql性能问题。
10. 使用不当，关联查询时容易产生分页bug。
11. 若不查询主键字段，容易造成查询出的对象有“覆盖”现象。
12. 参数的数据类型支持不完善。（如参数为Date类型时，容易报没有get、set方法，需在参数上加@param）
13. 多参数时，使用不方便，功能不够强大。（目前支持的方法有map、对象、注解@param以及默认采用012索引位的方式）
14. 缓存使用不当，容易产生脏数据。

Spring的缺点
虽然Spring的组件代码是轻量级的。但它的配置却是重量级的。
一开始。spring用XML配置，而且是很多XML配置。
Sring2.5引入了基于 注解的组件扫描，这消除了大量针对应用程序自身组件的显示XML配置。
Spring3.0引入了基于 java的配置 ,这是一种类型安全的可重构配置方式，可以代替XML。
所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行
思维切换，所以编写配置挤占了编写应用程序逻辑的时间。
和所有框架一样，Spring实用，但与此同时它要求的回报也不少。
此外，项目的依赖管理也是一件耗时耗力的事情。
在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。

Redis的缺点
1. 由于是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然redis本身有key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。
2. 如果进行完整重同步，由于需要生成rdb文件，并进行传输，会占用主机的CPU，并会消耗现网的带宽。不过redis2.8版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。
3. 修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，redis不能
提供服务。

Docker的缺点
内核漏洞
Docker内核攻击对于容器化环境来说可能是致命性的，因为容器与主机共享相同的系统内核，因此单独信任容器内置保护机制是不够的。
容器的隔离性使得某个应用程序的漏洞不会直接影响到其他容器的应用程序，但是漏洞可能会破坏与其他容器所共享的单一的操作系统，进而影响机器上的其他容器。如果漏洞允许代码执行，那么它将在主机操作系统上执行，而不是在容器内执行；如果此漏洞允许任意内存访问，则攻击者可以更改或读取任何其他容器的任何数据。
数据分离
在docker容器上，有一些非命名空间的资源：
SELinux
Cgroups
file systems under /sys, /proc/sys,
/proc/sysrq-trigger, /proc/irq, /proc/bus
/dev/mem, /dev/sd* file system
Kernel Modules
如果攻击者可以利用当中的任意一个元素，都将拥有主机系统的操作权限。
资源开销
Docker由于宿主机上的所有容器是共享相同的内核和相同的资源，如果对某些资源（CPU、内存、磁盘等）的访问不受限制，那么异常的容器将占用整个宿主机的资源，从而影响其他容器的运行，影响应用程序。
套接字问题
容器在默认情况下都安装了docker Unix套接字（/var/run/docker.sock），此套接字，可以关闭、启动或者创建新的镜像。
当你的容器启动并共享套接字的时候，你就给了容器操控宿主机的权限，它将可以启动或终止其它容器，在宿主机拖入或创建镜像，甚至写入到宿主机的文件系统。正确配置和保护，可以使用docker容器实现高级别的安全性，但它的安全性还是低于正确配置的VM。
```







# 自我介绍

```
你好，我叫李磊，毕业于一个普通的本科。之前是在杭州工作过，有三年的Java开发经验。
我有良好的Java基础，熟悉SSM和SpringBoot等主流的框架，有良好的编写SQL语句的能力。
能熟练使用Liunx系统和在使用docker在Liunx环境下部署项目。
还了解一些中间件nginx，redis，rabbitMq的使用，能够处理高并发请求和提高项目的性能。
也会Shiro等一些安全框架，保证项目的安全性。
```





1. ## 描述最熟悉的或者（最近）的一个项目？

   ```
   我现在最熟悉的一个项目就是==》浙江柘创智慧医养结合
   这个项目的目的就是将老人，养老院，医院联合起来，服务老人生活。在养老院的老人，家属可以通过手机查看自家老人在养老院的一些基本的情况。每个星期都会提醒家属来关爱老人。 
   ```

   

2. ## 描述在开发项目中遇到了哪些问题？怎么解决的?

   ```
   1，根据老人的情况来推荐给老人最合适的服务。
   2，对并发的处理，一天中可能某段时间是访问高峰期，比如早上7，8点的时候老人或来人的家属登录客户端查看，下午3点到4点之间的并发访问啊。
   ```

   ```
   1老人的信息是由家属来进行填写的，老人的病史，老人现在的健康状况和老人现在的用药情况等等，然后根据老人的这些情况进行分析，推荐给老人和家属最适合老人的产品和服务等等。
   2项目中是使用nginx反向代理服务器和redis非关系型数据库来解决项目的高并发问题，将数据库中的信息查询出来加入到redis缓存中在，用来降低并发对数据的访问压力。
   ```

   

3. ## 描述在开发项目中有哪些亮点？

   ```
   项目中的亮点就是：1，养老院中的信息是实时更新的，家属可以通过输入老人的信息查看老人现在的状况。
   				2，将养老院和社区老人进行结合，帮助老人了解养老院中的情况。
   ```

   

4. ## 看你简历上项目里用到的技术，框架、Redis、数据库等。针对这些技术问问题？

   ```
   1,Nginx应用场景
   2,什么是负载均衡
   3,Nginx负载均衡的规则有哪些
   4,集群分布式Session解决方案
   5,Redis的优点和缺点？
   6,Redis在什么情况下会进行持久化操作？
   7,Redis内存维护策略？
   8,Redis常用命令
   9，什么是Spring IOC？
   10，什么是Spring AOP?描述其应用场景（最少2个）
   11，AOP的通知有几个，分别是什么
   12，Spring Bean 注入有几种方式？  
   13，SpringBean 生命周期？
   14，描述Spring事务的隔离级别？
   15，Spring事务传播行为 REQUIRED和REQUIRES_NEW区别
   16，SpringMVC中的Bean是线程安全的吗？ 说出你的解决方案？ 
   17，SpringMVC的执行
   18，@RequestParam和@PathViriable的区别
   19，@Transactional注解作用
   20，@Configuration注解作用 (类上方声明)
   21，Redis持久化RDB和AOF区别
   22，Redis缓存和数据库一致性（工作中是如何将Redis和数据库数据进行同步的）
   23，缓存穿透是什么，解决方案、原因
   24，缓存雪崩是什么，解决方案、
   25，热点KEY处理，（缓存击穿）
   26，在mapper中如何传递多个参数，都有哪几种
   27，在用MyBatis插入时，如何得到数据库自增的主键值？
   28，MyBatis批量删除时，请问如何实现？
   29，MyBatis动态SQL执行流程和原理
   30，Redis集群特点
   31，Redis集群什么时候master不能用？
   32，redis的key清除策略
   33，什么是索引？索引的种类有哪些，描述索引的优缺点?
   ```

   

5. ## 你参与的功能模块深入细节？（用到了哪些表、表名叫什么、有哪些字段）?

   ```
   用到的older老人表：老人的一些基本的字段和老人的病例，联系人，是否在养老院等等。
   老人病例联合表，关联老人的主键id和病的类型。
   病例表 illness：1，病的类型
   		2，具体的病的名称
   权限表roles，医护人员，老人，老人家属，医生，养老院等等。
   ```

   

6. ## 线目上线部署过程？

7. ## 单元测试、或开发规范？

8. ## 如何在线上修复BUG？

9. ## 如果你的项目出现线上问题，你怎么解决？

10. ## 项目增加新功能，怎么和之前的功能同步运行使用？



```bat
前5道题。 如果面试官不问，回来找我，我请你吃饭
```

索引有哪些类型

```
1. FULLTEXT
即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。

2. HASH
由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。

3. BTREE
BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。

4. RTREE
RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。

5唯一索引
UNIQU

普通索引：仅加速查询
唯一索引：加速查询 + 列值唯一（可以有null）
主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
全文索引：对文本的内容进行分词，进行搜索
```



创建索引的规则

```
1.最左前缀匹配原则

非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2.=和in可以乱序

比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

3.尽量选择区分度高的列作为索引

区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录

4.索引列不能参与计算

保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);

5.尽量的扩展索引，不要新建索引。

比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可

6．选择唯一性索引

唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。

7．为经常需要排序、分组和联合操作的字段建立索引

经常需要ORDER BY、GROUP BY、DISTINCT和UNION等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。

8．为常作为查询条件的字段建立索引

如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。

9．限制索引的数目

索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦。越多的索引，会使更新表变得很浪费时间。

10．尽量使用数据量少的索引

如果索引的值很长，那么查询的速度会受到影响。例如，对一个CHAR(100)类型的字段进行全文检索需要的时间肯定要比对CHAR(10)类型的字段需要的时间要多。

11．尽量使用前缀来索引

如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。

12．删除不再使用或者很少使用的索引

表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。
```



