# 作业

1. ## 详细描述什么是Spring?

   1spring的核心是一个轻量级的容器

   2spring是实现ioc容器和非侵入式的框架

   3spring提供aop概念的实现方式

   4spring提供持久化层和事务层的支持

   5spring供mvc web框架的实现，并对一些常用的企业服务api提供一致的模型封装

   6spring提供了对现存的各种框架相整合的方案

2. ## 什么是Spring IOC？

   ioc即控制反转，不是技术，而是一种设计思想。在java开发中，ioc意味着将你设计好的对象交给容器控制，而不是传统的在你对象内部进行控制。

   控制反转：控制：ioc容器对你的对象进行控制，控制它的创建和外部资源的获取

   ​					反转：自己创建对象的方式叫做正转，而容器创建好的对象，用户直接注入依赖叫反转。

   

3. ## 什么是Spring AOP?描述其应用场景（最少2个）

   面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。

   AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。

   场景：统一日志处理

   ​			事务

   ​			shiro权限

   ​			缓存

4. ## AOP的通知有几个，分别是什么

   前置通知

   后置通知

   返回通知

   异常通知

   环绕通知

5. ## 描述Spring Bean的作用域？

   bean就是ioc容器创建和管理的java对象。

   bean的作用域

   | 类别          | 说明                                                         |
   | ------------- | ------------------------------------------------------------ |
   | singleton     | 在spring ioc容器中仅存在一个bean的实列，bean以单例方式存在   |
   | prototype     | 每次从容器中调用bean时，都返回一个新的实列，即每次调用getBean时，相当于执行new xxxbean（） |
   | request       | 每次HTTP请求都会创建一个新的bean，该作用域仅作用于webapplicationcontext环境 |
   | session       | 同一个HTTP session共享一个bean，不同session使用不同bean仅适合用于----- |
   | globalSession | 一般用于Portlet应用环境，该作用域仅适合-----                 |

   

6. ## Spring Bean 注入有几种方式？  

   1set方法注入  在xml文件中set类中的属性（前提是提供了set方法）

   2构造方法注入 通过类的构造函数在xml文件中设置类的属性值

   3静态工厂注入 在xml文件中调用工厂类的方法进行对象的创建

   4实列工厂注入 在xml文件中先创建实列工厂对象，再对实列工厂里面的方法进行调用创建对象

7. ## SpringBean 生命周期？

   ##  <img src="https://upload-images.jianshu.io/upload_images/4558491-dc3eebbd1d6c65f4.png?imageMogr2/auto-orient/strip|imageView2/2/w/823/format/webp" alt="img" style="zoom: 80%;" />

8. ## Spring框架中 用到了哪些设计模式？（不低于3个）

   工厂模式

   单例模式

   代理模式（aop中实现）

   观察者模式

   适配器模式（spring aop和spring mvc中的适配器模式）

   装饰者模式

9. ## 描述Spring事务传播行为？

   事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法时事务如何传播。

   | 事务类型                      | 说明                                                         |
   | ----------------------------- | ------------------------------------------------------------ |
   | PROPAGATION_REQUIRED（依赖）  | 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。 |
   | PROPAGATION_SUPPORTS          | 支持当前事务，如果当前没有事务，就以非事务方式执行。         |
   | PROPAGATION_MANDATORY（强制） | 使用当前的事务，如果当前没有事务，就抛出异常。               |
   | PROPAGATION_REQUIRES_NEW      | 如果当前没有事务，新建事务，如果当前存在事务，把当前事务挂起。 |
   | PROPAGATION_NOT_SUPPORTED     | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。   |
   | PROPAGATION_NEVER（从不）     | 以非事务方式执行，如果当前存在事务，则抛出异常。             |
   | PROPAGATION_NESTED（嵌套）    | 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则新建事务 |

10. ## 描述Spring事务的隔离级别？

    ````
    1. 读已提交 -> READ-COMMITTED    -> 防止脏读
    2. 读未提交 -> READ-UNCOMMITTED  -> 不能保证数据安全
    3. 可重复读 -> REPEATABLE-READ   -> 可以防止脏读和不可重复读
    4. 串行化   -> SERIALIZABLE      -> 防止脏读、幻读、不可重复读,但是性能较差
    ````

    ```
    脏读 ：一个事务读取的数据是另一个事务没有来的及提交的数据
    幻读：同一事务中，用同样的操作读两次，得到的记录数不一样
    不可重复度：同一事务，两次读取同一条数据，得到的内容不一样
    ```

    

11. ## Spring事务传播行为 REQUIRED和REQUIRES_NEW区别

    ```
    PROPAGATION_REQUIRED  如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。
    PROPAGATION_REQUIRES_NEW    如果当前没有事务，新建事务，如果当前存在事务，把当前事务挂起。
    ```

    
