1. ## 什么是线程？线程和进程的区别？

   

   可见性，有序性，原子性

   线程是操作系统能够进行运算调度的最小单位，他被包含在进程之中，是进程的实际运行单位。

   区别：1线程在进程之中进行运行

   ​			2一个进程可以包含多个线程

   ​			3不同进程间的数据很难共享

   ​			4统一进程下的线程信息很容易共享

   ​			5进程要比线程多.更消耗计算机资源

   ​			6进程之间不会有影响，但是一个线程挂掉将会导致整个进程挂掉

   ​			7进程使用的地址可以上锁

2. ## 描述CPU和多线程的关系

   CPU一般是多少核多少线程的。其中的核心数是cpu物理概念

   线程是cpu的模拟出来的，一个cpu核心能模拟出来2个核心数，那么一个cpu核心就能同时处理两个任务。

   cpu的核心数越多那么他的线程数也就越多，处理多线程的进程的能力就会越强。(CPU调用线程)

3. ## 什么是线程安全/线程不安全？

   线程安全：指的是多个线程在执行同一代码的时候采用加锁机制，使每次执行的结果和单线程值行的结果是一样的，不存在执行线程出现意外结果

   线程不安全：是指不提供加锁机制的保护，有可能出现多个线程先后更改数据造成得到的数据是脏数据

4. ## 描述下线程的生命周期？（画图）<img src="D:\FeiQ\五阶段\1584064711274.png" />

5. ## wait、sleep、join、yield的区别

   wait方法是属于Object类中的，wait的过程中会释放对象锁，只有其他线程调用notify方法的时候才能唤醒此线程

   sleep方法属于thread方法，sleep的过程中是不会释放对象锁的，只会阻塞线程，让出cpu给其他的线程。当时间到了该线程就会进入就绪状态，等待cpu的调用

   join等待调用join方法的线程结束之后，程序在继续执行，一般用于等待异步线程执行完结果之后才能继续运行的场景。

   yield和sleep一样都是Thread方法，都是暂停当前正在执行的线程对象，不会释放资源锁，和sleep不同的是yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态

6. ## Synchronized和Lock的区别

   | 类别       | synchronized                                                 | lock                                     |
   | ---------- | ------------------------------------------------------------ | ---------------------------------------- |
   | 存在层次上 | Java的关键字，在jvm层面上                                    | 是一个类                                 |
   | 锁的获取   | 使用synchronized的关键字获取锁                               | 使用lock方法来获取锁                     |
   | 锁的释放   | 1获取锁的线程执行完，自动释放锁。<br />2当获取锁的线程抛出异常的时候，jvm会制动释放锁 | 必须使用unlock方法来释放线程锁获得的锁。 |
   | 锁状态     | 无法判断                                                     | 可以判断                                 |
   | 锁类型     | 可重入，不可中断，非公平                                     | 可重入，可判断，可公平                   |
   | 性能       | 少量同步                                                     | 大量同步                                 |

   

7. ## ThreadLocal、Volatile、Synchronized 的作用和区别

   Volatile主要是用来在多线程中同步变量。

   ThreadLocal是一个线程的局部变量(其实就是一个Map),ThreadLocal会为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。

   synchronized关键字是Java利用锁的机制自动实现的，一般有同步方法和同步代码块两种使用方式。

8. ## 同步方法和同步块，个更好?

   同步块是更好的选择，因为它不会锁住整个对象。同步方法会锁住整个对象。

   同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。

9. ## 什么是死锁？如何避免死锁？

   死锁：当两个线程相互等待对方释放资源时，就会发生死锁。

   避免死锁：1加锁顺序：当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生

   ​					2死锁检测：每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。

   ​					3加锁时限：尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。

10. ## 常见的线程池叫什么，线程池的作用是什么

   线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。

   newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

   newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

   newScheduledThreadPool 创建一个周期线程池，支持定时及周期性任务执行。

   newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO， LIFO， 优先级）执行。

   作用：

   1、重用线程池的线程，可以避免因为线程的创建和销毁锁带来的性能开销

   2、可以有效的控制线程池的最大并发数，避免线程之间因为抢占系统资源而阻塞

   3、可以对线程进行简单的管理，除此之外，还可以提供以下的特定操作，例：提供定时、定期、单线程、并发数控制等功能
