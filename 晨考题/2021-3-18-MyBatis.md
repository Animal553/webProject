

1. ### 什么是MyBatis?

   ```
   1. 是一款优秀的持久层框架
   2. 支持定制化sql，存储过程以及高级映射
   3. 可以避免几乎所有的JDBC代码手动设置参数以及获取结果集
   4. 可以使用简单的 XML 或注解来配置和映射原生信息
   5. 用接口将Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录
   ```

   

2. ### #{}和${}的区别是什么？  *应用场景*

   ```
   #{} ： 根据参数的类型进行处理，比如传入String类型，则会为参数加上双引号。#{} 传参在进行SQL预编译时，会把参数部分用一个占位符 ? 代替，这样可以防止 SQL注入。
   ${} ： 将参数取出不做任何处理，直接放入语句中，就是简单的字符串替换，并且该参数会参加SQL的预编译，需要手动过滤参数防止 SQL注入。
   ```

   ```
   因此 mybatis 中优先使用 #{}；当需要动态传入 表名或列名时，再考虑使用 ${} 。
   
   其中 ${} 比较特殊， 他的应用场景是 需要动态传入 表名或列名时使用。
   ```

   

3. ### 在mapper中如何传递多个参数，都有哪几种

   ```
   第1种：使用Java对象，在映射文件中使用#{0}，#{1}代表传递进来的第几个参数。
   第3种: 使用@param注解:来命名参数
   第3种：使用Map集合作为参数来装载
   ```

   

1. ### 说出MyBatis动态标签（至少5个）

   ```
   if
   set
   choose
   foreach
   where
   ```

   

2. ### parameterType和resultType的区别

   ```
   parameterType是规定入参和入参类型的标签
   resultType是规定返回值的类型的标签
   ```

   

3. ### 在用MyBatis插入时，如何得到数据库自增的主键值？

   ```
   在mybatis的XML文件时，配置useGeneratedKeys和KeyProperty属性，且这两个属性不能省略。
   useGeneratedKeys属性，要求数据库本身具备主键自动增长的功能。
   KeyProperty属性，java对象的属性名，也就是要获取的字段。
   ```

   

4. ### MyBatis批量删除时，请问如何实现？

   ```
    <!-- 批量删除 -->
    <delete id="batchDeleteUsers">
    	DELETE FROM user WHERE user_id IN 
    	<foreach collection="list" item="id" open="(" separator="," close=")">
    		#{id}
    	</foreach>
    </delete>
   ```

   

5. ### MyBatis批量添加时，请问如何实现？

   ```
   <insert id="batchAddUser" parameterType="user">
    	INSERT INTO user(user_name,create_time) VALUES 
    	<foreach collection="list" item="item"  separator="," >
    		(#{item.userName},#{item.createTime})
    	</foreach>
    </insert>
   ```

   

6. ### MyBatis动态SQL执行流程和原理

   ```
   1.SqlResource 该接口含义是作为sql对象的来源，通过该接口可以获取sql对象。其唯一的实现类是XmlSqlResource，表示通过xml文件生成sql对象。
   2.Sql 该接口可以生成sql语句和获取sql相关的上下文环境(如ParameterMap、ResultMap等)，有三个实现类: RawSql表示为原生的sql语句，在初始化即可确定sql语句；SimpleDynamicSql表示简单的动态sql，即sql语句中参数通过方式指定，参数在sql生成过程中会被替换，不作为sql执行参数；DynamicSql表示动态sql，即sql描述文件中包含isNotNull等条件标签。
   3.SqlChild 该接口表示sql抽象语法树的一个节点，包含sql语句的片段信息。该接口有两个实现类: SqlTag表示动态sql片段，即配置文件中的一个动态标签，内含动态sql属性值(如prepend、property值等)；SqlText表示静态sql片段，即为原生的sql语句。每条动态sql通过SqlTag和SqlText构成相应的抽象语法树。
   4.SqlTagHandler 该接口表示SqlTag(即不同的动态标签)对应的处理方式。比如实现类IsEmptyTagHandler用于处理标签，IsEqualTagHandler用于处理标签等。
   5.SqlTagContext 用于解释sql抽象语法树时使用的上下文环境。通过解释语法树每个节点，将生成的sql存入SqlTagContext。最终通过SqlTagContext获取完整的sql语句。
   ```

   

7. ### JDBC为什么比Mybatis效率快？

   ```
   mybatis底层终究是调用jdbc的。而映射这东西不管是对象转一些值，还是一些值转对象，都需要调用反射api的
   ```

   

8. ### MyBatis框架中用到了哪些设计模式？（3个）

   ```
   工厂模式
   单例模式
   代理模式
   适配器模式
   装饰者模式
   ```

   

9. ### 缓存穿透是什么，解决方案、原因

   ```
   缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。
   
   持久层查询不到就缓存空结果，查询时先判断缓存中是否exists(key) ,如果有直接返回空，没有则查询后返回，
   注意insert时需清除查询的key，否则即便DB中有值也查询不到(当然也可以设置空缓存的过期时间）
   
   1、不管数据实际上存不存在，我们都把这个键存到缓存中（有效期设置的短一些，比如一分钟到三分钟），然后值设置为一个特定值，业务中如果获取到的结果是这个特定值，则报错返回。
   2、是使用 redis 的布隆过滤器（Bloom Filter），将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
   ```

   

10. ### 缓存雪崩是什么，解决方案、

    ```
    雪崩：缓存大量失效的时候，引发大量查询数据库。
    
    用锁/分布式锁或者队列串行访问
    缓存失效时间均匀分布
    ```

    

11. ### 热点KEY处理，（缓存击穿）

    ```
    热点key:某个key访问非常频繁，当key失效的时候有大量线程来构建缓存，导致负载增加，系统崩溃。
    
    1 使用锁，单机用synchronized,lock等，分布式用分布式锁。
    
    2 缓存过期时间不设置，而是设置在key对应的value里。如果检测到存的时间超过过期时间则异步更新缓存。
    
    3在value设置一个比过期时间t0小的过期时间值t1，当t1过期的时候，延长t1并做更新缓存操作。
    
    4设置标签缓存，标签缓存设置过期时间，标签缓存过期后，需异步地更新实际缓存 
    ```

    

12. ### Redis集群特点

    ```
    1、所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。
    2、节点的fail是通过集群中超过半数的节点检测失效时才生效。
    3、客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。
    4、redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配）,cluster 负责维护
    5、Redis集群预分好16384个哈希槽，当需要在 Redis 集群中放置一个 key-value 时， redis 先对key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节
    ```

    

13. ### Redis集群什么时候master不能用？

    ```
    当集群中大部分的redis服务器都挂掉后master不能用
    ```

    

14. ### 什么时候整个Redis集群不可用？

    ```
    a:如果集群任意master挂掉,且当前master没有slave.集群进入fail状态,也可以理解成集群的slot映射[0-16383]不完成时进入fail状态. 
    b:如果集群超过半数以上master挂掉，无论是否有slave集群进入fail状态.
    ```

    

15redis的key清除策略

```
惰性策略：当我们在访问过期key的时候，redis会判断此key是否过期，然后删除
定期策略：过一段时间只会对整个数据库进行遍历，然后删除过期key
内存淘汰机制：当内存大于maxmemory时，会对空间进行回收。
```

