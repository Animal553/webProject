#### 一. 事务

> 数据库的锁, 一个事务可以包裹多条执行语句, 被这些执行语句影响到的行,都会被锁起来 , 事务执行完毕的时候,会解锁

1. 表锁 : 当一个事务影响到当前表中的任意一条数据时, 当前表都会被锁住.其他事务无法操作表中的任何数据
   * 节省性能
2. 行锁 :  事务只会所以被其操作的数据, 当前表中的其他数据不会被影响到
   * 提高执行效率

#### 二. 事务单元的特性

* 原子性 

  > 同生共死 : 一个事务单元包裹的多条sql语句,必须同时成功,同时失败
  >
  > 原因 : 事务执行的过程中, 会产生一个针对当前事务的undo日志, 事务执行完毕之后, 日志销毁
  >
  > undo日志中记录着修改之前的状态, 一旦发生问题, 读取日志中的值, 修改回去
  >
  > 一旦修改完成, 日志销毁之后, 就没有办法获取数据之前的状态了, 所以也就没有办法恢复了

* 一致性(可见性)

  > 事务在执行的过程中, 不允许其他事务执行, 所以, 其他事务也无法得知当前事务的操作是是什么, 
  >
  > 也就是说, 当前事务执行的时候, 对其他事务来说是不可见的

* 隔离性

  > 数据库也允许我们将事务设置为可见
  >
  > 降低安全,提高效率

  1. 锁

     * 读锁 :  事务单元中只有查询
     * 写锁 : 事务单元中是修改语句
     * U型锁 :  update , 一旦一个事务中有任意的修改语句, 整个事务单元都被提升为写锁

  2. 隔离级别

     * 序列化读 : SERIALIABLE
       * 所有的事务都是串行的
     * 可重复读 : REPEATABLE READ
       * 读 和 读之间可以并行
     * 读已提交 : READ COMMITTED
       * 读写 , 读读 并行
     * 读未提交 : READ UNCOMMITTED
       * 写读 , 读写 , 读读 并行

  3. MVCC 模型 (多版本并发控制)

     1. 定义
        * 主要针对写读的优化
        * 快照隔离级别,现在的数据库被映射到REPEATABLE READ和READ UNCOMMITTED级别上
        * 通过以上的学习我们知道, READ UNCOMMITTED 这个级别虽然支持写读事务,但是是及其不安全的, 所以一般来说我们是不允许使用的, 那么有没有什么办法让我们既可以执行写读操作,又能保证数据的安全性呢?
        * 这里MVCC可以帮我们解决这个问题, 但是同时代理的消耗也会更高一些
     2. 实现原理
        * MVCC的实现主要是基于版本号, 这个版本号是基于一个逻辑时间戳的, 每个事务单元在操作数据的时候拿到的版本号是不同的
        * 比如说, 原始记录的版本号是1, 当有事务一进来执行写操作的时候,会在原始数据的基础上生成一个镜像,这个镜像的版本号就是2, 我们当前的写操作都在这个镜像上执行, 在当前事务没有完成之前, 别的事务是不知道这个版本号的, 他们看到的还是原始的版本号1 . 这时有个读的事务进来,他所能看到的只有版本1的记录, 从事务开始到结束都只能操作版本1的记录
     3. 逻辑时间戳
        * SCN(Oracle)
        * Trx_id(Innodb)

     

* 持久性

  >事务的持久性: 
  >
  >​	一旦事务完成, 做出修改就要保存到本地, 无法还原
  >
  >​	一旦对数据进行了修改, 那么, 数据库就会将修改之后的数据保存硬盘上
  >
  >数据库的持久性:
  >
  >group commit : 分组提交

#### 三. 死锁

> 多个事务相互等待对方解锁

1. 等锁超时 :  超出一定时间, 当前事务结束
2. 碰撞检测 :  等待中的事务会去主动查询是否使用自己需要的锁, 如果发现对象事务也在等待自己释放锁, 说明陷入了死锁, 终止一个事务
3. 数据的真正实现方式 :  碰撞检测 辅以等锁超时

#### 四. 乐观锁和悲观锁

> 加锁的态度
>
> 乐观锁就是尽量少加锁, 保证效率
>
> 悲观所就是尽量多加锁, 保证安全性

#### 五. 事务的问题

* 脏读 :  读取到其他事务未提交的数据, 这些数据可能回回滚
* 不可重复读 : 同一个事务中的多条查询语句查询的结果不同
* 幻读 :  刚才读取的数据, 再次读取发现没了

#### 六. 故障恢复

> 数据库在执行的时候是会记录日志的, 一旦出现问题, 可以根据日志进行恢复

#### 七. 事务编程

> 四个特性中, jdbc实际可用的,只有原子性

```java
@Test
    public void test3() throws SQLException {

        Connection cn = JDBCUtils.getConnection();
        cn.setAutoCommit(false);
        Statement stm = cn.createStatement();

        try {
            int n = stm.executeUpdate("insert into users values (default ,'123','123')");

            int i = 1 / 0;

            n = stm.executeUpdate("insert into users values (default ,'456','456')");
        }catch (Exception e){
            cn.rollback();
        }finally {
            cn.commit();

            JDBCUtils.release(stm, cn);
        }
    }
```

